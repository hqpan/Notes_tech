[TOC]



# 0. 版权声明

- SQL 系列读书笔记来源于 Ben Forta 所著《SQL 必知必会》[1]；
- 该系列笔记不以盈利为目的，仅用于个人学习、课后复习及科学研究；
- 如有侵权，请与本人联系（hqpan0@gmail.com），经核实后即刻删除；



# 1. SQL 基础

## 1.1 术语

|    英文     | 中文 |                          释义                           |
| :---------: | :--: | :-----------------------------------------------------: |
|   column    |  列  |         表中的一个字段，每列都有相应的数据类型          |
| primary key | 主键 |                            -                            |
|     row     |  行  |          表中的一个记录（record，非正式用语）           |
|   schema    | 模式 |                            -                            |
|    table    |  表  | 类似于EXCEL中的一张表，存储某种特定类型数据的结构化清单 |



## 1.2 概念释义

- DBMS 与 SQL 的区别：
  - DBMS：数据库管理系统，指数据库软件；
  - SQL：Structured Query Language，结构化查询语言；
- 模式：
  - 可用于描述表的特性，包括表中包含何种数据、数据如何分解、如何存储、各部分信息如何命名；
  - 也用于描述各个表之间的关系；
- 定义主键的要求：
  - 每行的主键值不能为`NULL`；
  - 主键值不得修改、重用；
  - 若将多列作为主键，则各列的组合值必须唯一（单个列的值允许相同）；
- SQL 语句执行时，忽略语句中的空格；
  - 可以使用缩进、换行提高程序可读性；



# 2. 检索数据

## 2.1 术语

|  英文   |  中文  | 释义 |
| :-----: | :----: | :--: |
| keyword | 关键字 |  -   |
|         |        |      |
|         |        |      |



## 2.2 检索

- 多条SQL语句以`；`分隔；

- SQL语句不区分大小写；

  - 将SQL关键字大写，列名和表名使用小写，提高代码可读性；

- 处理SQL语句时，忽略其中所有空格；
  - SQL语句可写在一行之中，也可写为多行；
  - 将SQL语句分成多行，易于阅读和调试；

- SQL一般返回原始的、无格式的数据；

- 按列检索：
  - 检索多列：用逗号分隔列名；
  ```mysql
  SELECT Prod_id, prod_name, prod_price 
  FROM Products;
  ```

  - 检索所有列：使用通配符；
    - 使用通配符可检测出列名未知的列；

  ```mysql
  SELECT *
  FROM Products;
  ```

- 检索不同的值：

  - 仅返回某一列中的值，每个不同的值仅显示一次；

  ```mysql
  SELECT DISTINCT vend_id
  FROM Products;
  ```

  - `DISTINCT`应置于列名之前，同时作用于多个列，会返回两列中的所有值，每个不同的值仅显示一次；

- 返回前若干行：不同的DBMS有不同的语法，以下语法仅针对MySQL；

  ```mysql
  SELECT prod_name
  FROM Products
  LIMIT 5;
  ```

  - 仅显示符合要求的前5行；

  ```mysql
  LIMIT 5 OFFSET 5;	-- MySQL支持简化版的 LIMIT 语句；
  LIMIT 3,4;			-- 第一个数字表示起始行，第二个数字表示需要返回的行数；
  ```

  - `OFFSET`后的数字表示起始行的编号，但检索时不包括该行，而是返回从下一行开始的检索结果；
    - 换言之，将该关键字后的行视为第0行，检索时仅返回从第1行开始的检索结果；

- 注释：

  ```mysql
  -- 两个连字符，实现行内注释；（多种 DBMS 支持该种形式的注释）
  #  一个井号，实现行内注释；（一小部分 DBMS 支持该种形式的注释）
  /* ... 多行注释 ... */ 
  ```

# 3. 排序检索数据

## 3.1 术语

|  英文  | 中文 | 释义 |
| :----: | :--: | :--: |
| clause | 子句 |  -   |
|        |      |      |
|        |      |      |

- 数据排序的具体规则取决于数据库管理员的设置方式；
  - A与a是否相同？
  - a位于B之前亦或是Z之后？
  - ……



## 3.2 排序数据

- 子句：SQL 语句由子句构成；

- `ORDER BY`子句应作为`SELECT`语句中的最后一个子句，否则报错；

  - 按单列排序：

  ```mysql
  ORDER BY prod_name;    -- 根据列名指定作为排序依据的列；
  ORDER BY 2;            -- 根据相对位置指定作为排序依据的列；
  ```
  - 按多个列排序：
  
  ```mysql
  ORDER BY prod_price, prod_name;
  ORDER BY 2,3;          -- 根据相对位置指定作为排序依据的列；
  ```
  
- 根据相对位置指定作为排序依据的列：

  - 优点：无需指定列名；
  - 缺点：不明确指定列名，容易引发排序错误；
  - 指定列名、使用相对列位置，两种方法可混用；



## 3.3 指定排序方向

- 升降序排列的关键字：

  - 降序：`DESC` 或 `DESCENDING`；

  - 升序：`ASC` 或 `ASCENDING`；
    - 由于`ORDER`默认按升序排列，因此该关键字无太大用处；

- 指定排序方向：

  - 升序排列：`ORDER`子句默认按升序排序；

  - 降序排列：在指定列后使用关键词`DESC`；

    ```mysql
    ORDER BY prod_price DESC;
    ```

  - 对多列进行降序排列：

    ```mysql
    ORDER BY prod_price DESC, prod_name;
    ```

    - `DESC`关键字仅作用于该关键字前的一列；
    - 如需制定多列按降序排列，应为每列加上`DESC`；




# 4. 过滤数据

## 4.1 术语

|               英文               |       中文        | 释义 |
| :------------------------------: | :---------------: | :--: |
| search criteria/filter condition | 搜索条件/过滤条件 |  -   |
|                                  |                   |      |
|                                  |                   |      |



## 4.2  WHERE 子句及操作符

- NULL不同于空字符串`""`、0、空格；
  
- `WHERE`子句的位置：
  
  - 应置于表名（`FROM`子句）之后；
  
  - 应置于`ORDER`子句之前；
  - `WHERE`子句后接条件操作符；
  
- 不同DBMS支持不同种类的操作符：

  - 具体差异参见相应 DBMS 文档；

  - 操作符存在冗余现象；

|   操作符    |             含义             |
| :---------: | :--------------------------: |
|     <>      |      不等于（等同于!=）      |
|     !>      | 不大于（等同于“小于等于”<=） |
|     !<      | 不小于（等同于“大于等于”>=） |
|   BETWEEN   |      在指定的两个值之间      |
|   IS NULL   |           为NULL值           |
| IS NOT NULL |          不为NULL值          |



## 4.3 使用操作符

- 若`WHERE`子句中涉及到字符串，则应使用单引号，用于限定字符串；

- `BETWEEN`操作符的使用方法：

    ```mysql
    WHERE prod_price BETWEEN 5 AND 10;
    ```

- 空值检查：
    - 注意：不能简单的检查某项是否等于NULL；
      - 原因：NULL不是一个数，各个NULL被认为不相同；
    ```mysql
    WHERE cust_email IS NULL;
    ```

# 5. 高级数据过滤

## 5.1 术语

|           英文            |       中文        | 释义 |
| :-----------------------: | :---------------: | :--: |
| operator/logical operator | 操作符/逻辑操作符 |  -   |
|                           |                   |      |

## 5.2 多个 WHERE 子句组合使用

- 常见的操作符：
  - `AND`、`OR`；
  - `IN`、`NOT`；

- `AND`操作符的用法：

  ```mysql
  WHERE vend_id = 'DLL01' AND prod_price <= 4;
  ```

- `OR`操作符：很多DBMS若判断`OR`操作符中第一个条件被满足，则不再判断第二个条件；

  - 可用n-1个操作符连接n个条件；
  - `AND`操作符的优先级高于`OR`操作符；
    - 注意：不过分依赖操作符的优先级，在`WHERE`子句中使用圆括号消除歧义；  

- `IN`操作符：指定匹配值清单，功能与`OR`相当；

  ```mysql
  WHERE vend_id IN ('DLL01', 'BRS01');
  ```

  - 使用`IN`操作符的理由：
    - `IN`操作符的语法更直观；
    - 当与其他操作符组合使用时，求值顺序易于管理；
    - 执行速度相较于`OR`操作符更快；
    - （最重要的优点）可以包含其他`SELECT`语句，便于更动态地建立`SELECT`子句；

- `NOT`操作符：

  ```mysql
  WHERE NOT vend_id = 'DLL01';
  ```

  - 大多数DBMS允许`NOT`操作符否定任何条件；



# 6. 用通配符进行过滤

## 6.1 术语

|      英文      |   中文   | 释义 |
| :------------: | :------: | :--: |
|    wildcard    |  通配符  |  -   |
| search pattern | 搜索模式 |  -   |
|   predicate    |   谓词   |  -   |

- 通配符的种类：不同的 DBMS 支持不同类型的通配符；
  - `%`：匹配任意数量的任意字符；
  - `_`：匹配某一个字符；
  - `[]`：匹配候选字符集中的某一个字符；
    - 仅有 Access、SQL Server 支持`[]`；
- 搜索模式：由字面值、通配符或两者组合构成的搜索条件；
- 不同的 DBMS 及配置，可以决定是否在搜索时区分大小写；



## 6.2 通配符的使用方法

- 通配符的使用要求：
  - `LIKE`操作符指示 DBMS，后接的搜索模式借助于通配符匹配；
    - 作为谓词使用时，操作符不再被视为操作符；
    - 从技术上分析，`LIKE`是谓词，而非操作符；
  - 通配符搜索仅适用于文本字段（字符串），不适用于非文本数据类型；
  - 通配符可以出现在搜索模式的任意位置，并且允许多个通配符同时使用；

- `%`通配符：

  - 能表示0个字符；

  - 不能匹配 NULL；

  - 很多 DBMS 使用空格填补字段内容，应如何处理？

    - E.g. 规定某列应有50个字符，但实际存储的文本的仅有17个字符，则在文本后附加33个空格；

    - Solution：如下代码中的第二个通配符用于匹配 y 之后的字符；

      ```mysql
      WHERE prod_name LIKE 'f%y%'
      ```

    - Better Solution：使用函数去除空格；

- `[]`通配符：在 Access 中，可用前缀字符`^`（脱字号）或`NOT`对该集合取反；

  - `^`相较于`NOT`的优点：应用于多个 WHERE 子句的情况时，可简化语法；

  ```mysql
  WHERE cust_contact LIKE '^[JM]%';   
  ```




## 6.3 使用通配符的原则

- 通配符的缺点：应用通配符进行搜索时，时间开销大；

  - 不过度使用通配符：若使用其它操作符能完成的功能，应尽量不使用通配符；

  - 尽量避免将通配符置于搜索模式的开头，否则将增大时间开销；

    ```mysql
    WHERE prod_name LIKE '% inch teddy bear';
    ```




# 7 创建计算字段

## 7.1 术语

|      英文      |    中文     |      释义      |
| :------------: | :---------: | :------------: |
|     field      |    字段     |       -        |
|  concatenate   |    拼接     | 将值联结到一起 |
| derived column | 导出列/别名 |       -        |

- 字段：与“列”的意思基本相同，常互换使用；

  - 数据库中的列一般称为“列”；
  - “字段”通常与“计算”一起使用，“计算字段”；



## 7.2 使用细节

- 字段并不实际存在于数据库表中，而是运行时在`SELECT`语句内创建的；

  - 此时`SELECT`语句返回一个计算字段（列）；

- 区分：

  - 只有数据库知道`SELECT`语句中哪些列是实际的表列，哪些列是计算字段；
  - 从客户端（E.g. 应用程序）来看，计算字段的数据与其他列的数据返回方式相同；
  - 很多格式转换和格式化工作，既可以在数据库服务器上完成，又可以在客户端应用程序内完成，但在数据库服务器上执行这些操作更快；

- 部分 DBMS 将计算字段保存为填充为列宽的文本值，有些时候需要去除这些多余的空格：

  - RTRIM()：除去字符串右侧空格；
  - LTRIM()：除去字符串左侧空格；
  - TRIM()：除去字符串两侧空格；
    - trim, vt.&n.修剪；

- MySQL 中使用函数`CONCAT`拼接两列：

  ```mysql
  SELECT CONCAT(vend_name, ' (', vend_country, ')')
  ```



## 7.3 使用别名

- 别名：亦称导出列；

- 使用关键字`AS`：

  ```mysql
  SELECT quantiyt*item_price AS expended_price
  ```

  - SQL 支持的基本算术运算包括：`+`、`-`、`*`、`/`；

- 别名的用途：

  - 为计算字段命名，便于客户端引用；

  - 当现有的表列名包含不合法字符（E.g. 空格）或易混淆时，可予以修正；

- 别名的命名原则：

  - 别名可以是一个单词或一个字符串，若为字符串，则应将字符串括在引号中；
    - 将字符串括在引号中，容易给客户端应用带来麻烦；
    - 推荐使用一个单词命名；

- `SELECT`语句可用于测试、检验函数、计算表达式；

  ```mysql
  SELECT 2*3			-- 计算表达式 2*3；
  SELECT NOW()		-- 返回当前时间和日期；
  ```

  

# 8. 使用函数处理数据

## 8.1 术语

|   英文   |   中文   | 释义 |
| :------: | :------: | :--: |
| portable | 可移植的 |  -   |

​    

## 8.2 使用 SQL 函数需要注意的问题

- 几乎所有的 DBMS 都支持相同的 SQL 语句，但各个 DBMS 的函数大多各不相同；

  - SQL 语句可移植；
  - SQL 函数不可移植；
    - 使用 SQL 函数应做好注释，以便于日后他人了解代码的功能；

- 若干个常用的函数：

  ```mysql
  SUBSTRING();		-- 提取字符串的组成部分；
  CONVERT();			-- 数据类型转换；
  
  NOW();				-- 返回语句开始执行的时间和日期；
  SYSDATE();			-- 返回执行该语句时的时间和日期；
  CURDATE();			-- 取当前日期；
  CURDATE();			-- 取当前日期；
  CURTIME();			-- 取当前时间；
  YEAR();				-- 从日期中提取年份；
  
  LENGTH();			-- 返回字符串的长度；
  SOUNDEX();			-- 返回字符串的SOUNDEX值；
  
  LEFT();				-- 返回字符串左边的字符；
  RIGHT(); 			-- 返回字符串右边的字符；
  
  LOWER();			-- 将字符串转换为小写；
  UPPER();			-- 将字符串转换为大写；
  ```

  - 关于 `SOUNDEX()` 函数：将文本串转换为其语音表示的字母数字模式；

  - 使用`SOUNDEX()` 函数检索虽拼写错误，但发音相近的文本串；

    ```mysql
    WHERE SOUNDEX(cust_contact) = SOUNDEX('Michael Green');
    ```

- 数值处理函数：

  ```mysql
  PI();				-- 返回圆周率；
  
  ABS();				-- 返回一个数的绝对值；
  SQRT();				-- 返回一个数的平方根；
  EXP();				-- 返回一个数的指数值；
  
  SIN();				-- 返回一个角度的正弦值；
  COS();				-- 返回一个角度的余弦值；
  TAN();				-- 返回一个角度的正切；
  ```




# 9. 汇总数据

## 9.1 术语

|        英文        |   中文   | 释义 |
| :----------------: | :------: | :--: |
| aggregate function | 聚集函数 |  -   |



## 9.2 5个聚集函数

- 各 DBMS 对聚集函数的支持基本一致；
- SQL 聚集函数：
  - `MAX()`；
  - `MIN()`；
  - `SUM()`；
  - `AVG()`；
  - `COUNT()`；

- `MAX()`：

  - 忽略值为 NULL 的行；
  - 可找出最大的数值或日期值；
  - 许多 DBMS 允许将该函数应用与文本数据，返回该列排序后的最后一行；

- `MIN()`：

  - 忽略值为 NULL 的行；
  - 许多 DBMS 允许将该函数应用与文本数据，返回该列排序后的最前面的一行；

- `SUM()`：

  - 忽略值为 NULL 的行；

- `AVG()`:

  - 忽略值为 NULL 的行；
  - 必须指定列名作为参数；

  - 只能用于单个列，若要获得多个列的均值，则需使用多个`AVG()`；

- `COUNT()`：

  ```mysql
  SELECT COUNT(*) AS num_cust		
  -- 以星号为参数，返回该列所有行的数量；
  SELECT COUNT(cust_email) AS num_cust  
  -- 以列名为参数，返回该列所有非空值的行的数量；
  ```

- `DISTINCT`参数对不同的值进行计算，`ALL`为默认参数，无需指定；

  - `DISTINCT`参数不必用于`MAX()`、`MIN()`中，无意义；

  - 由于该参数必须使用列名，因此不可用于`COUNT(*)`中；

  - 适用于如下情形：

    ```mysql
    SUM(DISTINCT column_name)   -- 返回该列中所有不同值之和
    AVG(DISTINCT column_name)   -- 返回该列中所有不同值的均值
    COUNT(DISTINCT column_name) -- 返回该列中所有不同值的行数
    ```

    

# 10. 分组数据

## 10.1 创建分组

- 创建分组：将数据分为多个逻辑组，分别进行聚集计算；

  ```mysql
  SELECT vend_id, COUNT(*) AS num_prods
  FROM Products
  GROUP BY vend_id;
  ```

  - `GROUP BY`子句按某列分组数据，故`COUNT(*)`表示对各个分组分别计数；

- `GROUP BY`的使用要求：

  - 该子句可包含任意数目的列，实现嵌套分组；

  - 该子句后接的每一列必须是检索列或有效的表达式，而不能是聚集函数；

    - 若在`SELECT`中使用表达式，则必须在`GROUP BY`子句中指定相同的表达式，不能使用别名；

  - 大多数 DBMS 不允许该子句后接长度可变的数据类型，E.g. 文本、备注型字段；

  - 除聚集计算语句之外，`SELECT`语句中的每列必须均在`GROUP BY`中给出；

  - 该子句将待分组列中值为 NULL 的所有行视为一组；

    


## 10.2 过滤分组

- `HAVING`与`WHERE`的区别：

  - `WHERE`过滤行；
    - 另一种理解：`WHERE`在数据分组前过滤；

  - `HAVING`过滤分组；
    - 另一种理解：`HAVING`在数据分组后过滤；
  - 两者可在同一语句中使用；

## 10.3 SELECT 子句顺序

 

|   子句   |        功能        |        是否必须使用        |
| :------: | :----------------: | :------------------------: |
|  SELECT  | 待返回的列或表达式 |             是             |
|   FROM   |   从中检索数据表   |  仅当从表中选择数据时使用  |
|  WHERE   |       过滤行       |             否             |
| GROUP BY |        分组        | 仅当分组实现聚集计算时使用 |
|  HAVING  |      过滤分组      |             否             |
| ORDER BY |        排序        |             否             |

   

# 11. 使用子查询

## 11.1 术语

| 英文  | 中文 | 释义 |
| :---: | :--: | :--: |
| query | 查询 |  -   |
|       |      |      |

- 查询：任何 SQL 语句均有查询功能，但该属于一般指代 `SELECT` 语句；
- 子查询常用于：
  - `WHERE`子句中的`IN`操作符中；
  - 作为计算字段使用子查询；
- 完全限定列名：表名、列名用句点分隔，E.g. `Orders.cust_id`；
  - 当操作涉及不同表，且其中的列名相同时，应使用完全限定列名；



## 11.2 在 WHERE 子句中利用子查询进行过滤

- 嵌套子查询无数量限制，但不宜过多；
- 子查询执行顺序为先内后外；
- 作为子查询的`SELECT`语句只能查询单个列；



# 12. 联结表

## 12.1 术语

|        英文         |      中文       | 释义 |
| :-----------------: | :-------------: | :--: |
|        join         |      连接       |  -   |
|        scale        |     可伸缩      |  -   |
|  cartesian product  |    笛卡尔积     |  -   |
|     cross join      |     叉联结      |  -   |
| equijoin/inner join | 等值联结/内联结 |      |

- 可伸缩：能够满足不断增加的工作量需求；
- 笛卡尔积：检索出的行数是第一张表的行数乘以第二张表的行数；
  - 叉联结：返回笛卡尔积的联结；



## 12.2 联结

- 联结：

  - 在一条`SELECT`语句中，连接多个表返回一组输出；
  - 联结的表越多，性能下降越严重；

- 等值连接；

- 创建联结：

  - 简单语法：

    ```mysql
    SELECT vend_name, prod_name, prod_price
    FROM Vendors, Products
    -- 联结两个表
    WHERE Vendors.vend_id = Products.vend_id;   
    
    -- 联结多个表，联结条件用AND连接；
    WHERE ... AND ...;							
    ```

  - 标准语法：

    - 明确指定连接的类型，此处为内联结；
    - 内联结的条件由`ON`子句给出；

    ```mysql
    SELECT vend_name, prod_name, prod_price
    FROM Vendors INNER JOIN Products
    ON Vendors.vend_id = Products_vend_id;
    ```


# 13. 创建高级联结

## 13.1 术语

|     英文     |   中文   | 释义 |
| :----------: | :------: | :--: |
|  self-join   |  自联结  |  -   |
| natural join | 自然联结 |  -   |
|  outer join  |  外联结  |  -   |
|              |          |      |

- 联结的种类：
  - 内联结；
  - 外联结；
  - 自联结；
  - 自然联结；
  - 等值联结；

## 13.2 使用表别名

- 表别名与列别名的区别：
  - 表别名仅在查询执行中使用，不返回到客户端；
  - 列别名返回至客户端；
- 使用表别名的优点：允许在一条 SQL 语句中多次使用相同的表；



## 13.3 自联结、自然联结和外联结

- 自联结：将一个表与其自身进行联结；

  - 自联结通常作为外部语句，相较于子查询语句，处理速度更快；

  - 因此自联结常用语替代从相同表中检索数据的子查询语句；

  - 实现方法：为同一个表取两个不同的别名；

  ```mysql
  WHERE Customers AS c1, Customers AS c2
  ```

    

- 自然联结：不同于标准的联结返回所有数据，自然联结中相同的列仅返回一次，即不返回两张表中相同的列；

  - 实现方法：对其中一个表使用通配符`SELECT *`，对其他表中的列使用明确的列名；

  ```mysql
  SELECT C.*, O.order_num, OI.prod_id
  ```

- 外联结：返回所有关联的行，以及部分没有关联的行；

  - 左外联结：`LEFT OUTER ... ON ...`；
  - 右外联结：`RIGHT OUTER ... ON ...`；

  ```mysql
  FROM ... LEFT OUTER JOIN ... ON ...
  -- 返回所有关联的行，以及左侧表中未被关联的行；
  
  FROM ... RIGHT OUTER JOIN ... ON ...
  -- 返回所有关联的行，以及右侧表中未被关联的行；
  ```

- 使用联结的原则;

  - 当使用多个联结时，可先分别测试各个联结，最后进行整体测试，以便排除错误；



# 14. 组合查询

## 14.1 术语

|         英文         |    中文     | 释义 |
| :------------------: | :---------: | :--: |
| union/compound query | 并/复合查询 |  -   |



## 14.2 使用组合查询

- 创建组合查询：

  - 使用关键词`UNION`将多个`SELECT`语句的返回结果作为并集输出；
  - `UNION`默认将重复的行只返回一次，`UNION ALL`将返回所有的重复行；

- 组合查询的使用原则：

  - 仅在最后一个`SELECT`语句后加分号；

  - 各查询必须包含相同的列、表达式、聚集函数（不必以相同的次序列出）；

  - 各列的数据类型必须兼容，即是 DBMS 可以隐含转换的类型；

  - `ORDER BY`子句仅在最后一条`SELECT`语句中出现一次；



# 15. 插入数据

## 15.1 INSERT 语句

- `INSERT`语句的功能：
  - 插入完整行；
  - 插入行中的部分项；
  - 插入某些查询的结果；



## 15.2 插入完整行

- 对未指定值的项，将其赋值为`NULL`；

- 尽量使用明确指定列名的`INSERT`语句；

  - 即使列的次序发生变化，也能正确填充数据；

  ```sql
  INSERT INTO Customers(cust_id,cust_name)
  VALUES('1000000006', 'Toy Land');
  
  INSERT INTO Customers				-- 不指定列名的填充；
  VALUES('1000000006', 'Toy Land');
  ```



## 15.3 插入行中的部分项

- 使用指定列名的`INSERT`语句，可省略部分项不填充，但须满足以下某个条件：
  - 在表的定义中，允许该列的值为`NULL`；
  - 在表的定义中给出默认值；
  - 即省略部分项时，将使用`NULL`或默认值；



## 15.4 插入某些查询的检索结果

- `INSERT  ... SELECT ...`语句根据列的位置填充，而非根据列名填充；

  - 即`SELECT`中的第一列填充至`INSERT`中的第一列；

  ```sql
  INSERT INTO Customers(cust_name, cust_id)
  SELECT cust_name, cust_id
  FROM CustNew;
  ```



## 15.5 将数据从一张表复制到另一张表

```sql
CREATE TABLE Customers AS
SELECT *
FROM Customers;
```

  

# 16. 更新和删除数据

## 16.1 更新数据

```sql
UPDATE Customers					-- 指定待更新的表名；
SET cust_contact = 'Sam Roberts'	-- 待更新的项用逗号分隔；
	cust_email = 'Sam@toyland.com'
WHERE cust_id = '1000000006';		-- 筛选待更新的行；
```



## 16.2 删除数据

- 使用外键的优点：确保引用完整性；

  - 避免删除某个与其他表相关联的行；

- 删除数据：

  - 删除某项：使用`UPDATE`将该项的值更新为`NULL`；

  - 删除整行：使用`DELETE`；

  ```SQL
  DELETE FROM Customers
  WHERE cust_id = '1000000006';
  ```

  - 删除所有行，但不删除表：

    - `DELETE`；

    - 更好的方法：`TRUNCATE TABLE`；

      - truncate，vt. 截断，舍位；

      - 因为不记录数据的表动，因此速度更快；



# 17. 创建、操纵表

## 17.1 创建表

```sql
CREATE TABLE Products
(
    prod_id 	CHAR(10) 		NOT NULL,
    quantity	INTEGER			NOT NULL		DEFAULT 1,
    prod_desc	TEXT(1000)		NULL
);
```

- 创建表的注意事项：
  - 创建表时，`NULL`为默认设置，无需额外声明；
  - 允许`NULL`的列不能作为主键；
  - 使用`DEFAULT`指定默认值；



## 17.2 更新、删除表

```sql
ALTER TABLE Vendors			-- 增加一列；
ADD vend_hone CHAR(20);

ALTER TABLE Vendors			-- 删除一列；
DROP COLUMN vend_phone;

DROP TABLE CustCopy;		-- 删除表；
```



# 18. 使用视图

## 18.1 视图的概念

- 视图自身不包含数据，仅包含查询语句；
- 视图命名不得与表名或其它视图相同；

- 覆盖或更新视图：先删除，后创建；

```sql
CREATE VIEW
DROP VIEW viewname;

CREATE VIEW ProductCustomers AS
SELECT ...
FROM ...
WHERE ... AND ...;
```

## 18.2 简化复杂 SQL 语句

- 使用视图，隐藏复杂的联结语句：

```sql
SELECT cust_name, cust_contact
FROM ProductCustomers			-- 此为视图名；
WHERE prod_id = 'RGAN01';
```








# ==Schedule==

- 每周一课，应于07月26日完成；
- 后续课程：数据库理论知识；
  - 购置配套教材一册；
    - 数据库系统概念(原书第6版.本科教学版)；
  - 配套实验教材或进阶SQL教材一册；
  - 每日一小时，补充数据库基础知识；



# References

[1] Ben Forta. SQL 必知必会[M]. 钟鸣, 刘晓霞 等译. 北京: 人民邮电出版社, 2013. ︎