[toc]

# 版权声明

- JVM 学习笔记来源周志明的著作《深入理解 Java 虚拟机》[1]；
- 该系列笔记不以盈利为目的，仅用于个人学习、课后复习及科学研究；
- 如有侵权，请与本人联系（hqpan@foxmail.com），经核实后即刻删除；
- 本文采用 [署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)](https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh) 协议发布；

# 1. Java 技术体系

- JCP：Java Community Process，Java 社区；
- JCP 定义的 Java 技术体系：
  - JDK：Java Development Kit，n.[C] 工具箱，支持 Java 程序开发的最小环境；
    - Java 程序设计语言；
    - Java 虚拟机：HotSpot 是 Sun/Oracle JDK 和 OpenJDK中的默认虚拟机，也是当前主流的虚拟机之一；
    - Java 类库 API；
  - `Class`文件格式；
  - 来自商业机构和开源社区的第三方 Java 类库；
- 按业务场景划分 Java 技术体系：
  - Java Card：支持 Java 小程序运行在小内存设备上的平台；
  - Java ME：Java Micro Edition，支持 Java 程序运行在移动终端上的平台，Android 不属于 Java ME；
  - Java SE：Java Standard Edition，支持面向桌面级应用（E.g. Windows 下的应用程序）的 Java 平台；
  - Java EE：Java Enterprise Edition，支持使用多层架构的企业应用的 Java 平台；
- JRE：Java Runtime Environment，支持 Java 程序运行的标准环境；
  - Java SE API：Java 类库 API 的子集；
  - Java 虚拟机；
- 核心包和扩展包：
  - 核心包：`java.*`；
  - 扩展包：`javax.*`；
  - 注意：部分曾是扩展包的 API 后来进入核心包中，因此核心包中也有部分包名为`java.*`；
- LTS：Long Term Support，长期支持版；

# 2. Java 内存区域与内存溢出异常

## 2.1 内存管理概述

- C++ 和 Java 在内存管理上的区别：
  - C++：拥有每个对象的“所有权”，维护对象的创建和删除过程，为每个`new`操作编写配对的`delete/free`代码；
  - Java：虚拟机提供自动内存管理机制，不容易出现内存泄漏、内存溢出问题，若出现上述问题，则不便排查和修正；

## 2.2 运行时数据区域

### 2.2.1 基本概念

- 运行时数据区域：JVM 执行程序时，将其管理的内存划分为若干数据区域；

|       运行时数据区域       | 线程共享 or 线程隔离 |
| :------------------------: | :------------------: |
|         程序计数器         |       线程共享       |
|       Java 虚拟机栈        |       线程共享       |
|         本地方法栈         |       线程共享       |
|          Java 堆           |       线程隔离       |
| 方法区（包含运行时常量池） |       线程隔离       |

![](./Picture/JVM运行时数据区.png)

- 数据区域的生命周期：
  - 随虚拟机进程启动而一直存在；
  - 随用户进程的启动、结束而建立、销毁；
- 概念模型：指所有虚拟机的统一外观，各款具体的虚拟机不一定完全按照概念模型的定义进行设计；

### 2.2.2 程序计数器

- 程序计数器：
  - 指示当前线程所执行的字节码的行号；
    - 若线程正在执行 Java 方法，则程序计数器记录正在执行的虚拟机字节码指令的地址；
    - 若线程正在执行本地（native）方法，则程序计数器值为空；
  - 字节码解释器通过程序计数器的值获取下一条待执行的字节码指令；
- 程序计数器中可能出现的异常：《Java 虚拟机规范》对除程序计数器以外的内存区域均规定了`OutOfMemoryError`（OOM）情况；

### 2.2.3 Java 虚拟机栈

- Java 虚拟机栈：描述 Java 方法执行的线程内存模型：
  - 每个方法被执行时，JVM 同步创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态连接、方法出口等信息；
  - 一个方法从被调用到执行完毕的过程，对应虚拟机栈中一个栈帧从入栈到出栈的过程；
- 局部变量表：存放编译期可知的数据类型；
  - 基本数据类型：
    - boolean；
    - 1 字节：byte；
    - 2 字节：char、short；
    - 4 字节：int、float；
    - 8 字节：long、double；
  - 引用数据类型：
    - 指向对象起始地址的引用指针；
    - 指向一个代表对象的句柄或其它与此对象相关的位置；
    - returnAddress类型，指向一条字节码指令的地址；
  - 局部变量槽（Slot）：表示局部变量表中各数据类型的存储空间：
    - long、double 类型的数据占用 2 个变量槽，其余数据类型占用 1 个变量槽；
    - 局部变量表所需的内存空间在编译时完成分配，一个方法在栈帧中所需的局部变量空间大小是确定的，在方法运行期间局部变量表的大小不变；
    - 注意：局部变量表的大小为变量槽的数量，虚拟机实际使用的内存空间大小由具体的虚拟机实现方式决定，E.g. 1 个变量槽占用 32 个比特、1 个变量槽占用 64个比特……
- 虚拟机栈中可能出现的异常：
  - `StackOverflowError`：线程请求的栈深度大于虚拟机允许的深度；
  - `OutOfMemoryError`：
    - 若虚拟机栈容量可动态扩展，则当栈扩展时无法申请到足够的内存将抛出该异常；
    - HotSpot 的栈容量不可动态扩展，仅在线程申请栈空间失败时才可能抛出`OutOfMemoryError`；

### 2.2.4 本地方法栈

- 虚拟机栈和本地方法栈的区别：HotSpot 将虚拟机栈和本地方法栈合二为一；
  - 虚拟机栈：为 JVM 执行的 Java 方法（字节码）服务；
  - 本地方法栈：为 JVM 使用到的本地方法服务；
- 本地方法：一般用 C、C++ 或汇编语言等编写，并被编译为基于本机硬件和操作系统的程序；
- 本地方法栈可能出现的异常：同虚拟机栈；

### 2.2.5 Java 堆

- Java 堆：亦称 GC 堆，Garbage Collected Heap，是 JVM 管理的所有内存中最大的一块，在堆上为所有对象实例和数组分配内存；
  - 内存空间：
    - Java 堆可使用物理上不连续的内存空间；
    - 对于数组等大对象，多数虚拟机要求连续的内存空间；
  - 扩展性：可被实现为固定大小，也可被实现为可扩展的（主流做法）；
- Java 堆可能出现的异常：
  - `OutOfMemoryError`：Java 堆中的内存不足以完成实例空间分配，且堆无法扩展时，将抛出该异常；
- TLAB：Thread Local Allocation Buffer，可从 Java 堆中划分出多个线程私有的分配缓冲区，提高内存分配效率；
  - 多线程在为对象分配内存时，修改用于分配内存的指针将是线程不安全的，采用 TLAB 可解决该问题；

### 2.2.6 方法区

- 方法区：在 JDK 8 后使用元空间代替永久代实现方法区；
  - 用途：存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据；
  - 特点：
    - 《Java 虚拟机规范》允许方法区不实现垃圾收集；
    - 垃圾收集行为在方法区不常见，该区域的内存回收目标是对常量池的回收和对类型的卸载；
- 运行时常量池：是方法区的一部分；
  - Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还包括常量池表，用于存放编译期生成的各种字面量与符号引用；
  - 常量池表将在类加载后存放到运行时常量池中；
- 运行时常量池和`Class`文件常量池的差别：
  - `Class`文件常量池：存放编译期产生的常量；
  - 运行时常量池：具备动态性；
  - Java 语言中常量可在编译期产生，也可在运行期间将新的常量放入池中；
- 方法区可能出现的异常：
  - `OutOfMemoryError`：方法区无法满足新的内存分配需求；

### 2.2.7 直接内存

- 直接内存：不属于“运行时数据区域”；
  - NIO（New Input/Output）类：
    - 引入一种基于通道（Channel）与缓冲区（Buffer）的I/O方式；
    - 使用 Native 函数库直接分配堆外内存，通过存储在 Java 堆中的 DirectByteBuffer 对象引用该内存；
    - 由于避免了在 Java 堆和 Native 堆中来回复制数据，可在部分场景下提高性能；
- 直接内存可能出现的异常：
  - `OutOfMemoryError`：
    - 直接内存的空间分配不受 Java 堆的大小限制，但会受本机总内存大小和处理器寻址空间的限制；
    - 若各内存区域之和大于物理内存限制，则将抛出该异常；

## 2.3 HotSpot 中的数据细节

### 2.3.1 对象的创建

- 内存分配方法：Java 堆中可用内存的地址空间是否连续，取决于采用的垃圾收集器是否带有空间压缩整理的能力；
  - 指针碰撞：若 Java 堆中可用内存的地址空间连续，则使用一个指针指示当前可用的内存起始地址；
  - 空闲列表：若 Java 堆中可用内存的地址空间不连续，则 JVM 维护一个列表，记录可用的内存块地址；
- 为什么 Java 对象未赋初值即可使用？
  - 内存分配完成后，JVM 将分配到的内存空间（不包括对象头）初始化为默认值；
  - 若使用了 TLAB，则在 TLAB 分配时初始化默认值；
- 对象头：Object Header；

### 2.3.2 对象的内存布局

- 对象在堆内存中的存储布局可划分为三个部分：
  - 对象头；
  - 实例数据：对象中的有效信息；
  - 对齐填充；
- 对象头：
  - 存储对象自身的运行时数据：哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳……
    - 该部分数据的长度在32位和64位的虚拟机中分别为32个比特和64个比特，官方称之为“Mark Word”；
  - 类型指针：对象指向它的类型元数据的指针，JVM 通过该指针确定该对象是哪个类的实例；
    - 不是所有的虚拟机实现都必须在对象数据上保留类型指针，即查找对象的元数据信息并不一定要经过对象本身；
    - JVM 通过元数据信息确定对象大小；
  - 注意：若对象为数组，则对象头中还有一块记录数组长度的数据，JVM 即可由此确定数组大小；
- 对齐填充：
  - HotSpot 的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，即任何对象的大小都必须是 8 字节的整数倍；
  - 对象头部分已被设计好，恰为 8 字节的倍数，若对象实例数据未对齐，则需通过对齐填充，补全占位符；

### 2.3.3 对象的访问定位

- Java 程序通过栈上的引用数据类型操作堆上的对象；
- 引用数据类型访问对象的方式：
  - 使用句柄：
    - Java 堆中划分一块内存作为句柄池，引用对象中存储该对象的句柄地址，句柄中包含对象实例数据和类型数据的地址；
    - 优点：引用对象中存储该对象的句柄地址，当对象被移动时（垃圾收集时移动对象是常见行为），无需修改引用对象本身，仅需修改句柄中的实例数据指针；
  - 直接指针：
    - 引用对象存储该对象的地址；
    - 优点：由于不需要访问句柄，节省了一次指针定位的时间开销，速度更快；

![](./Picture/通过句柄访问对象.png)

![](./Picture/通过直接指针访问对象.png)

## 2.4 处理 OutOfMemoryError

### 2.4.1 Java 堆溢出

- `java.lang.OutOfMemoryError: Java heap space`；

- 通过内存映像分析工具，分析由 Dump 得出的堆转储快照；
- 判断内存中引发 OOM 的对象是否是必要的，即判断发生了以下哪种情况：

  - 内存泄漏：通过工具查看泄漏对象到 GC Roots 的引用链，判断对象无法被回收的原因，定位对象的位置；
  - 内存溢出：即内存中的对象均应存活；
    - 宜检查堆参数设置，相较于机器的内存，尝试增加堆空间大小；
    - 判断是否存在部分对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，以减少内存消耗；


### 2.4.2 直接内存溢出

- 直接内存溢出的特征：Heap Dump 文件中无明显的异常，但内存溢出后产生的 Dump 文件较小，且程序中直接或间接使用了直接内存；

# 3. 垃圾收集器与内存分配策略

## 3.1 垃圾收集概述

- 垃圾收集：GC，Garbage Collection；
- 内存分配和回收：
  - 程序计数器、虚拟机栈、本地方法栈：线程私有，当线程结束后，该数据区域消失，无需进行垃圾回收；
  - Java 堆和方法区：方法区垃圾回收条件苛刻，回收所得内存少；

## 3.2 对象状态

### 3.2.1 对象状态判断方法

- 垃圾回收前，需找出无法访问的对象；
- 判断对象是否存活的算法：
  - 引用计数算法；
  - 可达性分析算法；
- 引用计数算法：
  - 在对象中添加一个引用计数器；
  - 若该对象增加一个引用，则计数器加 1；
  - 若该对象的某个引用失效，则计数器减 1；
  - E.g. 若两个对象间循环引用，则引用计数器永不为 0，导致无法回收该对象；
- 可达性分析算法：JVM 使用该方法判定对象是否可被回收；
  - 通过若干名为 GC Root 的根节点集；
  - 根节点通过引用链指向子节点，即被引用对象；
  - 若 GC Root 至某个节点无可达路径，则对象应被回收；
- 可作为 GC Root 的对象：
  - 虚拟机栈（栈帧中的本地变量表）中引用的对象；
  - 方法区中类静态属性引用的对象；
  - 方法区中常量引用的对象；
  - 本地方法栈中JNI（Java Native Interface，即本地方法）引用的对象；

### 3.2.2 对象的引用关系

- 强引用：
  - 使用`new`关键字创建强引用;
  - 若对象被强引用关联，则 GC 将不会回收该对象；
- 软引用：
  - 使用`SoftReference`类创建；
  - 系统发生内存溢出前，将回收被软引用关联的对象；
- 弱引用：
  - 使用`WeakReference`类创建；
  - 下一次 GC 开始工作时，将回收被弱引用关联的对象；
- 虚引用：其所关联的对象被 GC 回收时将收到系统通知；
  - 使用`PhantomReference`类创建；
  - 虚引用不影响被关联对象的生命周期；
  - 无法通过虚引用获取被关联的对象实例；

### 3.2.3 回收对象的过程

- finalize，vt. 完成，落实；
- 对象回收需经历 2 次标记过程：
  - 第 1 次标记：经可达性算法判定，对象与 GC Root 之间无引用链；
    - 判断对象是否有必要执行 finalize() 方法：
      - 没有必要执行 finalize() 方法：若对象未覆盖 finalize() 方法，或 finalize() 方法已被 JVM 调用过；
      - 有必要执行 finalize() 方法；
    - 若对象有必要执行 finalize() 方法，则将其置于名为 F-Queue 的队列中，稍后由一个被 JVM 自动建立的、低优先级的 Finalizer 线程执行对象的 finalize() 方法；
      - JVM 不承诺一定会等待对象的 finalize() 方法运行结束;
      - 避免因某对象的 finalize() 方法执行缓慢，或发生死循环，导致 F-Queue 队列中的剩余对象永久处于等待状态，引发内存回收子系统崩溃；
  - 第 2 次标记：收集器将对 F-Queue 中的对象进行第二次标记，若对象与引用链上的任一对象建立关联，则在第二次标记时将其移出“即将回收”的集合；
- 对象在回收过程中自救的机会仅有 1 次；
  - 一个对象的 finalize() 方法最多会被系统自动调用一次；
  - 当该对象第二次被回收时，finalize() 方法不再被执行；
- 在关闭外部资源时，try-finally 等方式更好，且finalize() 方法运行代价高，不确定性大，无法保证各个对象的调用顺序，官方不推荐使用该方法；

### 3.2.4 方法区垃圾收集

- 方法区垃圾回收的内容：
  - 常量池回收；
  - 类卸载：类需满足以下条件；
    - 该类所有的实例均被回收；
    - 加载该类的类加载器已被回收；
    - 该类对应的 java.lang.Class 对象未在任何地方被引用，无法通过反射访问该类的方法；
- 为避免内存溢出，在大量使用反射和动态代理的场景下，JVM 需具备类卸载功能；

# ==Unsolved==

- JVM 参数：
  - `-Xms20m`：Java 堆最小值设置为 20M；
  - `-Xmx20m`：Java 堆最大值设置为 20M；
  - `-XX:+HeapDumpOnOutOfMemoryError`：
    - 若发生 OOM，则 JVM 将 Dump 出内存堆转储快照，以便分析；
    - dump，vt. 倾倒，倾销，卸下，摆脱；
  - `-Xss128k`：设置栈容量，HotSpot 不区分虚拟机栈和本地方法栈；
  - `-XX：MaxMetaspaceSize`：设置元空间最大值，默认为 -1，即不限制元空间大小，仅受限于本地内存大小；
  - `-XX：MetaspaceSize`：设置元空间初始大小，以字节为单位，达到该值将触发垃圾收集进行类型卸载，垃圾收集器会动态调整该值；
    - 若释放了大量空间，则降低该值；
    - 若释放了较少空间，则在不超过元空间最大值（若已设置）的情况下增大该值；
  - `-XX：MinMetaspaceFreeRatio`：在垃圾收集后，控制最小的元空间剩余容量的百分比，降低因元空间不足引发的垃圾收集的频率；
  - `-XX：Max-MetaspaceFreeRatio`：控制最大的元空间剩余容量的百分比；
  - `-XX：MaxDirectMemorySize`：指定直接内存大小，若未设置该值，则默认和 Java 堆最大值保持一致；

# TODO

- [ ] Schedule：
  - 总页数：357 页；
  - 每天 20 页，7 月 03 日完成；
  - 当前进度：74 页，Chapter 3.2 已完成；
- [ ] 每天整理 2 道面试题；

# References

[1] 周志明. 深入理解 Java 虚拟机[M]. 北京: 机械工业出版社, 2019.