[toc]

# 版权声明

- JVM 学习笔记来源周志明的著作《深入理解 Java 虚拟机》[1]；
- 该系列笔记不以盈利为目的，仅用于个人学习、课后复习及科学研究；
- 如有侵权，请与本人联系（hqpan@foxmail.com），经核实后即刻删除；
- 本文采用 [署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)](https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh) 协议发布；

# 1. Java 技术体系

- JCP：Java Community Process，Java 社区；
- JCP 定义的 Java 技术体系：
  - JDK：Java Development Kit，n.[C] 工具箱，支持 Java 程序开发的最小环境；
    - Java 程序设计语言；
    - Java 虚拟机：HotSpot 是 Sun/Oracle JDK 和 OpenJDK中的默认虚拟机，也是当前主流的虚拟机之一；
    - Java 类库 API；
  - `Class`文件格式；
  - 来自商业机构和开源社区的第三方 Java 类库；
- 按业务场景划分 Java 技术体系：
  - Java Card：支持 Java 小程序运行在小内存设备上的平台；
  - Java ME：Java Micro Edition，支持 Java 程序运行在移动终端上的平台，Android 不属于 Java ME；
  - Java SE：Java Standard Edition，支持面向桌面级应用（E.g. Windows 下的应用程序）的 Java 平台；
  - Java EE：Java Enterprise Edition，支持使用多层架构的企业应用的 Java 平台；
- JRE：Java Runtime Environment，支持 Java 程序运行的标准环境；
  - Java SE API：Java 类库 API 的子集；
  - Java 虚拟机；
- 核心包和扩展包：
  - 核心包：`java.*`；
  - 扩展包：`javax.*`；
  - 注意：部分曾是扩展包的 API 后来进入核心包中，因此核心包中也有部分包名为`java.*`；
- LTS：Long Term Support，长期支持版；

# 2. Java 内存区域与内存溢出异常

## 2.1 内存管理概述

- C++ 和 Java 在内存管理上的区别：
  - C++：拥有每个对象的“所有权”，维护对象的创建和删除过程，为每个`new`操作编写配对的`delete/free`代码；
  - Java：虚拟机提供自动内存管理机制，不容易出现内存泄漏、内存溢出问题，若出现上述问题，则不便排查和修正；

## 2.2 运行时数据区域

### 2.2.1 基本概念

- 运行时数据区域：JVM 执行程序时，将其管理的内存划分为若干数据区域；

|       运行时数据区域       | 线程共享 or 线程隔离 |
| :------------------------: | :------------------: |
|         程序计数器         |       线程共享       |
|       Java 虚拟机栈        |       线程共享       |
|         本地方法栈         |       线程共享       |
|          Java 堆           |       线程隔离       |
| 方法区（包含运行时常量池） |       线程隔离       |

![](./Picture/JVM运行时数据区.png)

- 数据区域的生命周期：
  - 随虚拟机进程启动而一直存在；
  - 随用户进程的启动、结束而建立、销毁；
- 概念模型：指所有虚拟机的统一外观，各款具体的虚拟机不一定完全按照概念模型的定义进行设计；

### 2.2.2 程序计数器

- 程序计数器：
  - 指示当前线程所执行的字节码的行号；
    - 若线程正在执行 Java 方法，则程序计数器记录正在执行的虚拟机字节码指令的地址；
    - 若线程正在执行本地（native）方法，则程序计数器值为空；
  - 字节码解释器通过程序计数器的值获取下一条待执行的字节码指令；
- 程序计数器中可能出现的异常：《Java 虚拟机规范》对除程序计数器以外的内存区域均规定了`OutOfMemoryError`（OOM）情况；

### 2.2.3 Java 虚拟机栈

- Java 虚拟机栈：描述 Java 方法执行的线程内存模型：
  - 每个方法被执行时，JVM 同步创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态连接、方法出口等信息；
  - 一个方法从被调用到执行完毕的过程，对应虚拟机栈中一个栈帧从入栈到出栈的过程；
- 局部变量表：存放编译期可知的数据类型；
  - 基本数据类型：
    - boolean；
    - 1 字节：byte；
    - 2 字节：char、short；
    - 4 字节：int、float；
    - 8 字节：long、double；
  - 引用数据类型：
    - 指向对象起始地址的引用指针；
    - 指向一个代表对象的句柄或其它与此对象相关的位置；
    - returnAddress类型，指向一条字节码指令的地址；
  - 局部变量槽（Slot）：表示局部变量表中各数据类型的存储空间：
    - long、double 类型的数据占用 2 个变量槽，其余数据类型占用 1 个变量槽；
    - 局部变量表所需的内存空间在编译时完成分配，一个方法在栈帧中所需的局部变量空间大小是确定的，在方法运行期间局部变量表的大小不变；
    - 注意：局部变量表的大小为变量槽的数量，虚拟机实际使用的内存空间大小由具体的虚拟机实现方式决定，E.g. 1 个变量槽占用 32 个比特、1 个变量槽占用 64个比特……
- 虚拟机栈中可能出现的异常：
  - `StackOverflowError`：线程请求的栈深度大于虚拟机允许的深度；
  - `OutOfMemoryError`：
    - 若虚拟机栈容量可动态扩展，则当栈扩展时无法申请到足够的内存将抛出该异常；
    - HotSpot 的栈容量不可动态扩展，仅在线程申请栈空间失败时才可能抛出`OutOfMemoryError`；

### 2.2.4 本地方法栈

- 虚拟机栈和本地方法栈的区别：HotSpot 将虚拟机栈和本地方法栈合二为一；
  - 虚拟机栈：为 JVM 执行的 Java 方法（字节码）服务；
  - 本地方法栈：为 JVM 使用到的本地方法服务；
- 本地方法：一般用 C、C++ 或汇编语言等编写，并被编译为基于本机硬件和操作系统的程序；
- 本地方法栈可能出现的异常：同虚拟机栈；

### 2.2.5 Java 堆

- Java 堆：亦称 GC 堆，Garbage Collected Heap，是 JVM 管理的所有内存中最大的一块，在堆上为所有对象实例和数组分配内存；
  - 内存空间：
    - Java 堆可使用物理上不连续的内存空间；
    - 对于数组等大对象，多数虚拟机要求连续的内存空间；
  - 扩展性：可被实现为固定大小，也可被实现为可扩展的（主流做法）；
- Java 堆可能出现的异常：
  - `OutOfMemoryError`：Java 堆中的内存不足以完成实例空间分配，且堆无法扩展时，将抛出该异常；
- TLAB：Thread Local Allocation Buffer，可从 Java 堆中划分出多个线程私有的分配缓冲区，提高内存分配效率；
  - 多线程在为对象分配内存时，修改用于分配内存的指针将是线程不安全的，采用 TLAB 可解决该问题；

### 2.2.6 方法区

- 方法区：
  - 用途：存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据；
  - 特点：
    - 《Java 虚拟机规范》允许方法区不实现垃圾收集；
    - 垃圾收集行为在方法区不常见，该区域的内存回收目标是对常量池的回收和对类型的卸载；
- 运行时常量池：是方法区的一部分；
  - Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还包括常量池表，用于存放编译期生成的各种字面量与符号引用；
  - 常量池表将在类加载后存放到运行时常量池中；
- 运行时常量池和`Class`文件常量池的差别：
  - `Class`文件常量池：存放编译期产生的常量；
  - 运行时常量池：具备动态性；
  - Java 语言中常量可在编译期产生，也可在运行期间将新的常量放入池中；
- 方法区可能出现的异常：
  - `OutOfMemoryError`：方法区无法满足新的内存分配需求；

### 2.2.7 直接内存

- 直接内存：不属于“运行时数据区域”；
  - NIO（New Input/Output）类：
    - 引入一种基于通道（Channel）与缓冲区（Buffer）的I/O方式；
    - 使用 Native 函数库直接分配堆外内存，通过存储在 Java 堆中的 DirectByteBuffer 对象引用该内存；
    - 由于避免了在 Java 堆和 Native 堆中来回复制数据，可在部分场景下提高性能；
- 直接内存可能出现的异常：
  - `OutOfMemoryError`：
    - 直接内存的空间分配不受 Java 堆的大小限制，但会受本机总内存大小和处理器寻址空间的限制；
    - 若各内存区域之和大于物理内存限制，则将抛出该异常；

## 2.3 HotSpot 中的数据细节

### 2.3.1 对象的创建

- 内存分配方法：Java 堆中可用内存的地址空间是否连续，取决于采用的垃圾收集器是否带有空间压缩整理的能力；
  - 指针碰撞：若 Java 堆中可用内存的地址空间连续，则使用一个指针指示当前可用的内存起始地址；
  - 空闲列表：若 Java 堆中可用内存的地址空间不连续，则 JVM 维护一个列表，记录可用的内存块地址；
- 为什么 Java 对象未赋初值即可使用？
  - 内存分配完成后，JVM 将分配到的内存空间（不包括对象头）初始化为默认值；
  - 若使用了 TLAB，则在 TLAB 分配时初始化默认值；
- 对象头：Object Header；

### 2.3.2 对象的内存布局

- 对象在堆内存中的存储布局可划分为三个部分：
  - 对象头；
  - 实例数据：对象中的有效信息；
  - 对齐填充；
- 对象头：
  - 存储对象自身的运行时数据：哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳……
    - 该部分数据的长度在32位和64位的虚拟机中分别为32个比特和64个比特，官方称之为“Mark Word”；
  - 类型指针：对象指向它的类型元数据的指针，JVM 通过该指针确定该对象是哪个类的实例；
    - 不是所有的虚拟机实现都必须在对象数据上保留类型指针，即查找对象的元数据信息并不一定要经过对象本身；
    - JVM 通过元数据信息确定对象大小；
  - 注意：若对象为数组，则对象头中还有一块记录数组长度的数据，JVM 即可由此确定数组大小；
- 对齐填充：
  - HotSpot 的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，即任何对象的大小都必须是 8 字节的整数倍；
  - 对象头部分已被设计好，恰为 8 字节的倍数，若对象实例数据未对齐，则需通过对齐填充，补全占位符；

### 2.3.3 对象的访问定位

- Java 程序通过栈上的引用数据类型操作堆上的对象；
- 引用数据类型访问对象的方式：
  - 使用句柄：
    - Java 堆中划分一块内存作为句柄池，引用对象中存储该对象的句柄地址，句柄中包含对象实例数据和类型数据的地址；
    - 优点：引用对象中存储该对象的句柄地址，当对象被移动时（垃圾收集时移动对象是常见行为），无需修改引用对象本身，仅需修改句柄中的实例数据指针；
  - 直接指针：
    - 引用对象存储该对象的地址；
    - 优点：由于不需要访问句柄，节省了一次指针定位的时间开销，速度更快；

![](./Picture/通过句柄访问对象.png)

![](./Picture/通过直接指针访问对象.png)

# TODO

- [ ] Schedule：
  - 总页数：485 页；
  - 每天16页，7月12日完成；
  - 当前进度：52 页，Chapter 2.3 已完成；

# References

[1] 周志明. 深入理解 Java 虚拟机[M]. 北京: 机械工业出版社, 2019.