[toc]

# 版权声明

- 《数据库系统概念》系列学习笔记来源于 Abraham Silberschatz，Henry F.Korth 和 S.Sudarshan 所著 *Database System Concepts 6th edition* [1]，以及  Ben Forta 所著《SQL必知必会》[2]；
- 该系列笔记不以盈利为目的，仅用于个人学习、课后复习及科学研究；
- 如有侵权，请与本人联系（hqpan@foxmail.com），经核实后即刻删除；
- 本文采用 [署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)](https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh) 协议发布；



# 1. 数据库基本概念

## 1.1 定义

- DBMS: database management system ;
- DBS：Database System；
- SQL:  Structured Query Language ，结构化查询语言；
  - 发音：为字母 S-Q-L 或 sequel ['sikwəl] ；
- UML：Unified Modeling Language，统一建模语言；

## 1.2 数据视图

- 数据抽象：
  - 物理层；
  - 逻辑层：数据间的关系，与物理层之间存在物理数据独立性；
  - 视图层；
- 实例：instance，某个时刻数据库中所有信息的集合；
- 模式：schema，数据库的总体设计，描述表的特性，E.g. 表中包含何种数据、数据如何分解、如何存储、各部分信息如何命名、各个表之间的关系；；
  - 物理模式：在物理层描述数据库的设计；
  - 逻辑模式：在逻辑层描述数据库的设计，使用该模式构造应用程序；
  - 子模式：subschema，即数据库在视图层的模式；
- 数据模型：
  - 关系模型：relational model，表示数据间的关联；
  - 实体-联系模型：entity-relationship model，E-R；
  - 基于对象的数据模型：object-based data model，即面向对象的数据模型；
  - 半结构化数据模型：semistructured data model；



## 1.3 数据库语言

- 数据库语言的不同部分;
  - 数据操纵语言；
  - 数据定义语言：输出存放在包含元数据的数据字典中，数据字典仅能由 DBS 自身访问和修改；
- 一致性约束：
  - 域约束：每个属性均有对应的取值范围约束；
  - 参照完整性约束：某些属性集在不同关系中出现，其值必须相等；
  - 断言；
  - 授权；



## 1.4 事务管理

- 事务正确执行的四个基本要素：简写为 ACID；
  - 原子性：Atomicity；
  - 一致性：Consistency；
  - 隔离性：Isolation；
  - 持久性：Durability；
- 事务执行前后，数据库均满足一致性条件；



## 1.5 数据库体系结构

- 数据库体系结构:
  - 集中式数据库；
  - 客户机/服务器系统；
  - 并行数据库系统；
  - 分布式数据库系统；
- 度量数据库系统性能的指标：
  - 吞吐量：给定时间内完成的事务数量；
  - 响应时间：完成单个事务所需时间；



# 2. 关系模型介绍

## 2.1 定义

- attribute：属性，用于指代列；
- domain：域，每个属性所有可能取值的集合；
- relation/table：关系，用于指代表；
- row / record: 行 / 记录；
- tuple：元组，数学上指一组值的序列，数据库中用于指代行；
- n-tuple：n 元组，有 n 个值的元组，对应于表中的一行；



## 2.2 码

- foreign key: 外码，即外键，父数据表的主键；
- primary key: 主码，即主键；
  - 主键值不能为空，不能修改、重用，若某行从表中删除，则它的主键不能赋给以后的新行；
  - 可取多个 column 组合作为主键；
- 参照关系和被参照关系：E.g. 一个关系模式$r_1$的属性中含有另一个关系模式$r_2$的主键；
  - 参照关系：$r_1$为外键依赖的参照关系；
  - 被参照关系：



# 3. SQL

## 3.1 定义和语言特点

- DDL 和 DML;
  - DDL：Data-Defination Language，数据定义语言；
  - DML：Data-Manipulation Language，数据操纵语言；
- 空值会给数据的访问和更新带来不便，应减少使用；
- SQL语句不区分大小写，将关键字大写，列名和表名小写，提高代码可读性；
- 单条 SQL 语句执行时，忽略其中所有空格，多条SQL语句以`;`分隔；

  - SQL语句可写在一行之中，也可写为多行；
  - 将SQL语句分成多行，易于阅读和调试；
- 注释：
  - `-- `：两个连字符，单行注释；
  - `#`：单行注释；
  - `/*...*/ `：多行注释；



## 3.2 数据定义

### 3.2.1 基本类型

- 基本类型：
  - `char(n)`；固定长度字符串；
  - `varchar(n)`；可变长度字符串；
  - `int`；
  - `smallint`：小整数类型；
  - `numeric(p,d)`：定点数；
  - `float(n)`；
  - `real, double precision`：浮点数与双精度浮点数；
- 注意：
  - 两个`char`比较时，将自动追加空格，使得两者便于比较；
  - `char`和`varchar`比较时，无法自动追加空格补齐长度，建议将两者均设置为`varchar`便于比较；



### 3.2.2 基本模式定义

```mysql
... not null;			-- 属性值不得为空；
insert into r values (...);	-- 向关系r中插入一个记录；
drop from r;			-- 删除关系r及其模式；
delete from r;			-- 删除关系r中的所有记录；
alter table r add A D;	-- 向关系r中添加属性A，该属性的域为D；
alter table r drop A;	-- 删除关系r中的属性A；
```



## 3.3 SQL 查询的基本结构

### 3.3.1 查询和自然连接

- `all`与`distinct`：
  - `all`：显式指定在结果中保留重复值，可省略；
  - `distinct`：去重；
- `select`子句中可使用运算符：$+、-、\times、\div$；
  - 运算对象：常数、属性；
- `where`子句中可使用逻辑连词：`and`，`or`，`not`；
  - `where`缺省，则表示为`true`；
- 若多个关系中的属性名相同，则使用关系名作为前缀加以区分；
- 自然连接：natural join；
  - 连接两个关系中**所有**共有属性值相等的元组，可连接多个关系；
  - 亦可连接两个关系中**部分**共有属性值相等的元组；

```mysql
from r1 natural join r2 natural join r3;
from r1 natural join r2 using A;	-- 连接属性A相等的元组；
```

- 返回前若干行：其中`OFFSET`后的数字表示起始行的编号，但检索时不包括该行，而是返回从下一行开始的检索结果；

```mysql
SELECT prod_name
FROM Products
LIMIT 5;			-- 返回前5行；
-- 其它方案
LIMIT 5 OFFSET 5;	-- MySQL支持简化版的 LIMIT 语句；
LIMIT 3,4;	-- 第一个数字表示起始行，第二个数字表示需要返回的行数；
```



### 3.3.2 附加基本运算

- 重命名：`as`可用于`select`或`from`语句中;

  - 相关名称/相关变量/元组变量：即重命名关系的标识符；

- 字符串运算：

  - SQL 中使用单引号表示字符串；
  - 若字符串中含有单引号，则使用连续两个单引号表示一个单引号，E.g. `''`；
  - 模式匹配：使用比较运算符`like`；
    - 百分号：匹配任意子串；
    - 下划线：匹配任意一个字符；
  - 定义转义字符：关键字`escape`；

  ```mysql
  like 'ab\%' escape '\';		-- 定义反斜杠为转义字符
  ```



# ==Schedule==

- 仅学习前12章，12月31日前完成 chapter 1-6；
- 每天10-11页，30天完成334页；
- 每天整理旧版本笔记1-2章；
- Page 46，3.5 已完成；

# References

[1] 杨冬靑, 李红燕, 唐世渭. 数据库系统概念[M]. 机械工业出版社, 2013. 
[2] Forta B, 钟鸣, 刘晓霞. SQL 必知必会[J]. 2013.



# 旧版本笔记分割线

# 3. 排序检索数据

## 3.1 术语

|  英文  | 中文 | 释义 |
| :----: | :--: | :--: |
| clause | 子句 |  -   |

- 数据排序的具体规则取决于数据库管理员的设置方式；
  - A与a是否相同？
  - a位于B之前亦或是Z之后？

## 3.2 排序数据

- `ORDER BY`子句应作为`SELECT`语句中的最后一个子句，否则报错；

  - 按单列排序：

  ```mysql
  ORDER BY prod_name;    -- 根据列名指定作为排序依据的列；
  ORDER BY 2;            -- 根据相对位置指定作为排序依据的列；
  ```

  - 按多个列排序：

  ```mysql
  ORDER BY prod_price, prod_name;
  ORDER BY 2,3;          -- 根据相对位置指定作为排序依据的列；
  ```

- 根据相对位置指定作为排序依据的列：

  - 优点：无需指定列名；
  - 缺点：不明确指定列名，容易引发排序错误；
  - 指定列名、使用相对列位置，两种方法可混用；



## 3.3 指定排序方向

- 升降序排列的关键字：

  - 降序：`DESC` 或 `DESCENDING`；
  - 升序：`ASC` 或 `ASCENDING`，默认值，可省略；
    - 由于`ORDER`默认按升序排列，因此该关键字无太大用处；

- 指定排序方向：

  - 升序排列：`ORDER`子句默认按升序排序；

  - 降序排列：在指定列后使用关键词`DESC`；

    ```mysql
    ORDER BY prod_price DESC;
    ```

- 对多列进行降序排列：

  ```mysql
    ORDER BY prod_price DESC, prod_name;
  ```

  - `DESC`仅作用于该关键字指定的列；
  - 如需制定多列按降序排列，应为每列加上`DESC`；



# 4. 过滤数据

## 4.1  WHERE 子句及操作符

- `WHERE`子句的位置：

  - 应置于表名（`FROM`子句）之后；
  - 应置于`ORDER`子句之前；
  - `WHERE`子句后接条件操作符；

- 不同DBMS支持不同种类的操作符：

  - 具体差异参见相应 DBMS 文档；
  - 操作符存在冗余现象；

|   操作符    |         含义         |
| :---------: | :------------------: |
|     <>      |  不等于（等同于!=）  |
|     !>      |  不大于（等同于<=）  |
|     !<      |  不小于（等同于>=）  |
|   between   |  在指定的两个值之间  |
| not between | 不在指定的两个值之间 |
|   IS NULL   |       为null值       |



## 4.3 使用操作符

- `BETWEEN`操作符的使用方法：

  ```mysql
  WHERE prod_price BETWEEN 5 AND 10;
  
  ```

- 空值检查：

  - 注意：不能简单的检查某项是否等于NULL；
    - 原因：NULL不是一个数，各个NULL被认为不相同；

  ```mysql
  WHERE cust_email IS NULL;
  
  
  ```

# 5. 高级数据过滤

## 5.1 术语

|           英文            |       中文        | 释义 |
| :-----------------------: | :---------------: | :--: |
| operator/logical operator | 操作符/逻辑操作符 |  -   |
|                           |                   |      |

## 5.2 多个 WHERE 子句组合使用

- 常见的操作符：

  - `AND`、`OR`；
  - `IN`、`NOT`；

- `AND`操作符的用法：

  ```mysql
  WHERE vend_id = 'DLL01' AND prod_price <= 4;
  
  
  ```

- `OR`操作符：很多DBMS若判断`OR`操作符中第一个条件被满足，则不再判断第二个条件；

  - 可用n-1个操作符连接n个条件；
  - `AND`操作符的优先级高于`OR`操作符；
    - 注意：不过分依赖操作符的优先级，在`WHERE`子句中使用圆括号消除歧义；  

- `IN`操作符：指定匹配值清单，功能与`OR`相当；

  ```mysql
  WHERE vend_id IN ('DLL01', 'BRS01');
  
  
  ```

  - 使用`IN`操作符的理由：
    - `IN`操作符的语法更直观；
    - 当与其他操作符组合使用时，求值顺序易于管理；
    - 执行速度相较于`OR`操作符更快；
    - （最重要的优点）可以包含其他`SELECT`语句，便于更动态地建立`SELECT`子句；

- `NOT`操作符：

  ```mysql
  WHERE NOT vend_id = 'DLL01';
  
  
  ```

  - 大多数DBMS允许`NOT`操作符否定任何条件；



# 6. 用通配符进行过滤

## 6.1 术语

|      英文      |   中文   | 释义 |
| :------------: | :------: | :--: |
|    wildcard    |  通配符  |  -   |
| search pattern | 搜索模式 |  -   |
|   predicate    |   谓词   |  -   |

- 通配符的种类：不同的 DBMS 支持不同类型的通配符；
  - `%`：匹配任意数量的任意字符；
  - `_`：匹配某一个字符；
  - `[]`：匹配候选字符集中的某一个字符；
    - 仅有 Access、SQL Server 支持`[]`；
- 搜索模式：由字面值、通配符或两者组合构成的搜索条件；
- 不同的 DBMS 及配置，可以决定是否在搜索时区分大小写；



## 6.2 通配符的使用方法

- 通配符的使用要求：

  - `LIKE`操作符指示 DBMS，后接的搜索模式借助于通配符匹配；
    - 作为谓词使用时，操作符不再被视为操作符；
    - 从技术上分析，`LIKE`是谓词，而非操作符；
  - 通配符搜索仅适用于文本字段（字符串），不适用于非文本数据类型；
  - 通配符可以出现在搜索模式的任意位置，并且允许多个通配符同时使用；

- `%`通配符：

  - 能表示0个字符；

  - 不能匹配 NULL；

  - 很多 DBMS 使用空格填补字段内容，应如何处理？

    - E.g. 规定某列应有50个字符，但实际存储的文本的仅有17个字符，则在文本后附加33个空格；

    - Solution：如下代码中的第二个通配符用于匹配 y 之后的字符；

      ```mysql
      WHERE prod_name LIKE 'f%y%'
      
      
      ```

    - Better Solution：使用函数去除空格；

- `[]`通配符：在 Access 中，可用前缀字符`^`（脱字号）或`NOT`对该集合取反；

  - `^`相较于`NOT`的优点：应用于多个 WHERE 子句的情况时，可简化语法；

  ```mysql
  WHERE cust_contact LIKE '^[JM]%';   
  
  
  ```



## 6.3 使用通配符的原则

- 通配符的缺点：应用通配符进行搜索时，时间开销大；

  - 不过度使用通配符：若使用其它操作符能完成的功能，应尽量不使用通配符；

  - 尽量避免将通配符置于搜索模式的开头，否则将增大时间开销；

    ```mysql
    WHERE prod_name LIKE '% inch teddy bear';
    
    
    ```



# 7 创建计算字段

## 7.1 术语

|      英文      |    中文     |      释义      |
| :------------: | :---------: | :------------: |
|     field      |    字段     |       -        |
|  concatenate   |    拼接     | 将值联结到一起 |
| derived column | 导出列/别名 |       -        |

- 字段：与“列”的意思基本相同，常互换使用；
  - 数据库中的列一般称为“列”；
  - “字段”通常与“计算”一起使用，“计算字段”；



## 7.2 使用细节

- 字段并不实际存在于数据库表中，而是运行时在`SELECT`语句内创建的；

  - 此时`SELECT`语句返回一个计算字段（列）；

- 区分：

  - 只有数据库知道`SELECT`语句中哪些列是实际的表列，哪些列是计算字段；
  - 从客户端（E.g. 应用程序）来看，计算字段的数据与其他列的数据返回方式相同；
  - 很多格式转换和格式化工作，既可以在数据库服务器上完成，又可以在客户端应用程序内完成，但在数据库服务器上执行这些操作更快；

- 部分 DBMS 将计算字段保存为填充为列宽的文本值，有些时候需要去除这些多余的空格：

  - RTRIM()：除去字符串右侧空格；
  - LTRIM()：除去字符串左侧空格；
  - TRIM()：除去字符串两侧空格；
    - trim, vt.&n.修剪；

- MySQL 中使用函数`CONCAT`拼接两列：

  ```mysql
  SELECT CONCAT(vend_name, ' (', vend_country, ')')
  
  
  ```



## 7.3 使用别名

- 别名：亦称导出列；

- 使用关键字`AS`：

  ```mysql
  SELECT quantiyt*item_price AS expended_price
  
  
  ```

  - SQL 支持的基本算术运算包括：`+`、`-`、`*`、`/`；

- 别名的用途：

  - 为计算字段命名，便于客户端引用；
  - 当现有的表列名包含不合法字符（E.g. 空格）或易混淆时，可予以修正；

- 别名的命名原则：

  - 别名可以是一个单词或一个字符串，若为字符串，则应将字符串括在引号中；
    - 将字符串括在引号中，容易给客户端应用带来麻烦；
    - 推荐使用一个单词命名；

- `SELECT`语句可用于测试、检验函数、计算表达式；

  ```mysql
  SELECT 2*3			-- 计算表达式 2*3；
  SELECT NOW()		-- 返回当前时间和日期；
  
  
  ```

  

# 8. 使用函数处理数据

## 8.1 术语

|   英文   |   中文   | 释义 |
| :------: | :------: | :--: |
| portable | 可移植的 |  -   |

​    

## 8.2 使用 SQL 函数需要注意的问题

- 几乎所有的 DBMS 都支持相同的 SQL 语句，但各个 DBMS 的函数大多各不相同；

  - SQL 语句可移植；
  - SQL 函数不可移植；
    - 使用 SQL 函数应做好注释，以便于日后他人了解代码的功能；

- 若干个常用的函数：

  ```mysql
  SUBSTRING();		-- 提取字符串的组成部分；
  CONVERT();			-- 数据类型转换；
  
  CURDATE();			-- 取当前日期；
  YEAR();				-- 从日期中提取年份；
  
  LENGTH();			-- 返回字符串的长度；
  SOUNDEX();			-- 返回字符串的SOUNDEX值；
  
  LEFT();				-- 返回字符串左边的字符；
  RIGHT(); 			-- 返回字符串右边的字符；
  
  LOWER();			-- 将字符串转换为小写；
  UPPER();			-- 将字符串转换为大写；
  
  
  ```

  - 关于 `SOUNDEX()` 函数：将文本串转换为其语音表示的字母数字模式；

  - 使用`SOUNDEX()` 函数检索虽拼写错误，但发音相近的文本串；

    ```mysql
    WHERE SOUNDEX(cust_contact) = SOUNDEX('Michael Green');
    
    
    ```

- 数值处理函数：

  ```mysql
  PI();				-- 返回圆周率；
  
  ABS();				-- 返回一个数的绝对值；
  SQRT();				-- 返回一个数的平方根；
  EXP();				-- 返回一个数的指数值；
  
  SIN();				-- 返回一个角度的正弦值；
  COS();				-- 返回一个角度的余弦值；
  TAN();				-- 返回一个角度的正切；
  
  
  ```



# 9. 汇总数据

## 9.1 术语

|        英文        |   中文   | 释义 |
| :----------------: | :------: | :--: |
| aggregate function | 聚集函数 |  -   |



## 9.2 5个聚集函数

- 各 DBMS 对聚集函数的支持基本一致；

- SQL 聚集函数：

  - `MAX()`；
  - `MIN()`；
  - `SUM()`；
  - `AVG()`；
  - `COUNT()`；

- `MAX()`：

  - 忽略值为 NULL 的行；
  - 可找出最大的数值或日期值；
  - 许多 DBMS 允许将该函数应用与文本数据，返回该列排序后的最后一行；

- `MIN()`：

  - 忽略值为 NULL 的行；
  - 许多 DBMS 允许将该函数应用与文本数据，返回该列排序后的最前面的一行；

- `SUM()`：

  - 忽略值为 NULL 的行；

- `AVG()`:

  - 忽略值为 NULL 的行；
  - 必须指定列名作为参数；
  - 只能用于单个列，若要获得多个列的均值，则需使用多个`AVG()`；

- `COUNT()`：

  ```mysql
  SELECT COUNT(*) AS num_cust		
  -- 以星号为参数，返回该列所有行的数量；
  SELECT COUNT(cust_email) AS num_cust  
  -- 以列名为参数，返回该列所有非空值的行的数量；
  
  
  ```

- `DISTINCT`参数对不同的值进行计算，`ALL`为默认参数，无需指定；

  - `DISTINCT`参数不必用于`MAX()`、`MIN()`中，无意义；

  - 由于该参数必须使用列名，因此不可用于`COUNT(*)`中；

  - 适用于如下情形：

    ```mysql
    SUM(DISTINCT column_name)   -- 返回该列中所有不同值之和
    AVG(DISTINCT column_name)   -- 返回该列中所有不同值的均值
    COUNT(DISTINCT column_name) -- 返回该列中所有不同值的行数
    
    
    ```

    

# 10. 分组数据

## 10.1 创建分组

- 创建分组：将数据分为多个逻辑组，分别进行聚集计算；

  ```mysql
  SELECT vend_id, COUNT(*) AS num_prods
  FROM Products
  GROUP BY vend_id;
  
  
  ```

  - `GROUP BY`子句按某列分组数据，故`COUNT(*)`表示对各个分组分别计数；

- `GROUP BY`的使用要求：

  - 该子句可包含任意数目的列，实现嵌套分组；

  - 该子句后接的每一列必须是检索列或有效的表达式，而不能是聚集函数；

    - 若在`SELECT`中使用表达式，则必须在`GROUP BY`子句中指定相同的表达式，不能使用别名；

  - 大多数 DBMS 不允许该子句后接长度可变的数据类型，E.g. 文本、备注型字段；

  - 除聚集计算语句之外，`SELECT`语句中的每列必须均在`GROUP BY`中给出；

  - 该子句将待分组列中值为 NULL 的所有行视为一组；

    

## 10.2 过滤分组

- `HAVING`与`WHERE`的区别：
  - `WHERE`过滤行；
    - 另一种理解：`WHERE`在数据分组前过滤；
  - `HAVING`过滤分组；
    - 另一种理解：`HAVING`在数据分组后过滤；
  - 两者可在同一语句中使用；

## 10.3 SELECT 子句顺序

 

|   子句   |        功能        |        是否必须使用        |
| :------: | :----------------: | :------------------------: |
|  SELECT  | 待返回的列或表达式 |             是             |
|   FROM   |   从中检索数据表   |  仅当从表中选择数据时使用  |
|  WHERE   |       过滤行       |             否             |
| GROUP BY |        分组        | 仅当分组实现聚集计算时使用 |
|  HAVING  |      过滤分组      |             否             |
| ORDER BY |        排序        |             否             |

   

# 11. 使用子查询

## 11.1 术语

| 英文  | 中文 | 释义 |
| :---: | :--: | :--: |
| query | 查询 |  -   |
|       |      |      |

- 查询：任何 SQL 语句均有查询功能，但该属于一般指代 `SELECT` 语句；
- 子查询常用于：
  - `WHERE`子句中的`IN`操作符中；
  - 作为计算字段使用子查询；
- 完全限定列名：表名、列名用句点分隔，E.g. `Orders.cust_id`；
  - 当操作涉及不同表，且其中的列名相同时，应使用完全限定列名；



## 11.2 在 WHERE 子句中利用子查询进行过滤

- 嵌套子查询无数量限制，但不宜过多；
- 子查询执行顺序为先内后外；
- 作为子查询的`SELECT`语句只能查询单个列；



# 12. 联结表

## 12.1 术语

|        英文         |      中文       | 释义 |
| :-----------------: | :-------------: | :--: |
|        join         |      连接       |  -   |
|        scale        |     可伸缩      |  -   |
|  cartesian product  |    笛卡尔积     |  -   |
|     cross join      |     叉联结      |  -   |
| equijoin/inner join | 等值联结/内联结 |      |

- 可伸缩：能够满足不断增加的工作量需求；
- 笛卡尔积：检索出的行数是第一张表的行数乘以第二张表的行数；
  - 叉联结：返回笛卡尔积的联结；



## 12.2 联结

- 联结：

  - 在一条`SELECT`语句中，连接多个表返回一组输出；
  - 联结的表越多，性能下降越严重；

- 等值连接；

- 创建联结：

  - 简单语法：

    ```mysql
    SELECT vend_name, prod_name, prod_price
    FROM Vendors, Products
    -- 联结两个表
    WHERE Vendors.vend_id = Products.vend_id;   
    
    -- 联结多个表，联结条件用AND连接；
    WHERE ... AND ...;							
    
    
    ```

  - 标准语法：

    - 明确指定连接的类型，此处为内联结；
    - 内联结的条件由`ON`子句给出；

    ```mysql
    SELECT vend_name, prod_name, prod_price
    FROM Vendors INNER JOIN Products
    ON Vendors.vend_id = Products_vend_id;
    
    
    ```

# 13. 创建高级联结

## 13.1 术语

|     英文     |   中文   | 释义 |
| :----------: | :------: | :--: |
|  self-join   |  自联结  |  -   |
| natural join | 自然联结 |  -   |
|  outer join  |  外联结  |  -   |
|              |          |      |

- 联结的种类：
  - 内联结；
  - 外联结；
  - 自联结；
  - 自然联结；
  - 等值联结；

## 13.2 使用表别名

- 表别名与列别名的区别：
  - 表别名仅在查询执行中使用，不返回到客户端；
  - 列别名返回至客户端；
- 使用表别名的优点：允许在一条 SQL 语句中多次使用相同的表；



## 13.3 自联结、自然联结和外联结

- 自联结：将一个表与其自身进行联结；

  - 自联结通常作为外部语句，相较于子查询语句，处理速度更快；
  - 因此自联结常用语替代从相同表中检索数据的子查询语句；
  - 实现方法：为同一个表取两个不同的别名；

  ```mysql
  WHERE Customers AS c1, Customers AS c2
  
  
  ```

    

- 自然联结：不同于标准的联结返回所有数据，自然联结中相同的列仅返回一次，即不返回两张表中相同的列；

  - 实现方法：对其中一个表使用通配符`SELECT *`，对其他表中的列使用明确的列名；

  ```mysql
  SELECT C.*, O.order_num, OI.prod_id
  
  
  ```

- 外联结：返回所有关联的行，以及部分没有关联的行；

  - 左外联结：`LEFT OUTER ... ON ...`；
  - 右外联结：`RIGHT OUTER ... ON ...`；

  ```mysql
  FROM ... LEFT OUTER JOIN ... ON ...
  -- 返回所有关联的行，以及左侧表中未被关联的行；
  
  FROM ... RIGHT OUTER JOIN ... ON ...
  -- 返回所有关联的行，以及右侧表中未被关联的行；
  
  
  ```

- 使用联结的原则;

  - 当使用多个联结时，可先分别测试各个联结，最后进行整体测试，以便排除错误；



# 14. 集合运算

## 14.1 定义

- 集合运算：将多个`SELECT`语句的返回结果执行集合运算后输出；
  - 并运算：`union`；
  - 交运算：`intersect`；
  - 并运算：`except`；

## 14.2 集合运算

- 并运算：
  - `union`：对重复行，只返回一次；
  - `union all`：返回所有重复行；
- 交运算：
  - `intersect`；
  - `intersect all`；
- 并运算：
  - `except`；
  - `except all`：当前者的重复元素数量大于后者时，才会出现在结果中；
- 组合查询的使用原则：
  - 仅在最后一个`SELECT`语句后加分号；
  - 各查询必须包含相同的列、表达式、聚集函数（不必以相同的次序列出）；
  - 各列的数据类型必须兼容，即是 DBMS 可以隐含转换的类型；
  - `ORDER BY`子句仅在最后一条`SELECT`语句中出现一次；



# 15. 插入数据

## 15.1 INSERT 语句

- `INSERT`语句的功能：
  - 插入完整行；
  - 插入行中的部分项；
  - 插入某些查询的结果；



## 15.2 插入完整行

- 对未指定值的项，将其赋值为`NULL`；

- 尽量使用明确指定列名的`INSERT`语句；

  - 即使列的次序发生变化，也能正确填充数据；

  ```sql
  INSERT INTO Customers(cust_id,cust_name)
  VALUES('1000000006', 'Toy Land');
  
  INSERT INTO Customers				-- 不指定列名的填充；
  VALUES('1000000006', 'Toy Land');
  
  
  ```



## 15.3 插入行中的部分项

- 使用指定列名的`INSERT`语句，可省略部分项不填充，但须满足以下某个条件：
  - 在表的定义中，允许该列的值为`NULL`；
  - 在表的定义中给出默认值；
  - 即省略部分项时，将使用`NULL`或默认值；



## 15.4 插入某些查询的检索结果

- `INSERT  ... SELECT ...`语句根据列的位置填充，而非根据列名填充；

  - 即`SELECT`中的第一列填充至`INSERT`中的第一列；

  ```sql
  INSERT INTO Customers(cust_name, cust_id)
  SELECT cust_name, cust_id
  FROM CustNew;
  ```



## 15.5 将数据从一张表复制到另一张表

```sql
CREATE TABLE Customers AS
SELECT *
FROM Customers;
```
