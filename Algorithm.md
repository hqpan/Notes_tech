

[TOC]

# 0. 版权声明
- Algorithms 系列学习笔记来源于 Kevin Wayne 和 Robert Sedgewick 在 Coursera 网站上所授课程 *Algorithms, parts I and II* [1,2]，课程教材 *Algorithms 4th edition* [3]；
- 该系列笔记不以盈利为目的，仅用于个人学习、课后复习及科学研究；
- 如有侵权，请与本人联系（hqpan@foxmail.com），经核实后即刻删除；
- 本文采用 [署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)](https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh) 协议发布；

# 1. 算法基础
- 算法与数据结构的区别：
  - 算法：method for solving a problem；
  - 数据结构：method to store information；
- 设计算法的步骤：
  -  建立数学模型；
  -  设计一种算法求解；
  -  若不满足对内存和运行速度的要求，则查找原因，修改算法；

## 1.1 基础编程模型

- ADT：abstract data type，抽象数据类型；

- API：application programming interface，应用程序接口；

- 格式化输出：
  - 若输出值的宽度大于指定的宽度，则指定无效；
  - 对于字符串，小数点后的值表示截取的长度；
  
- 结束输入流：`ctrl+d`或`ctrl+z`，取决于具体的终端应用程序；

- 管道：将一个程序的输出重定向为另一个程序的输入；

- 使用未经初始化的变量，将出现编译错误；

- Q：静态方法与函数的区别？

  - 在一些其他语言中，静态方法被称为函数；
  - 使用`static`区分静态方法和实例方法；

- 数组：

  - 数组的声明、创建和初始化：

  ```java
  int[] array;			// 声明；
  array = new int[10];	// 创建；
  ```

  - Q：为什么创建数组时需要指出数组大小？
    - 便于编译器预留空间；

- 原始数据类型：

  - `boolean`：布尔型，1字节；
  - 因为计算机访问内存的方式为：一次1字节；
  - `char`：字符型，2字节；
  - `float`：4字节，同`int`；

- `for`与`while`的区别：

  - `for`循环中的递增变量在循环结束后，通常是不可用的；
    - 原因：`for`循环中的递增变量通常定义在循环体内；
  - `while`循环中的递增变量在循环结束后仍是可用的；
  
- 除以0;

  - `2/0`，异常；
  - `2.0/0.0`：infinity，无穷大；



## 1.2 数据抽象

- `new`关键字/构造函数返回对象的引用；
- 静态方法与实例方法的差别：
  - 静态方法：通过类名调用，参量为方法的参数；
  - 实例方法：通过对象名调用，参量为对象的引用和方法的参数；
- 包括数组在内的所有非原始数据类型的值均为对象；
- 封装类型：原始数据类型对应的引用类型；
  - 每种原始数据类型均有对应的封装类型，E.g. Boolean、Byte ...；
  - Java 将在必要时自动将原始数据类型转换为封装类型；
- `final`只能确保原始数据类型的不可变性，不能实现引用类型的不可变性；
  - 引用类型中的实例变量被`final`修饰时，表示该实例变量的值（即某个对象的引用）不可变；
  - E.g. 以下代码示例中，实例变量永远指向同一个对象，但对象的值本身仍可改变；

```java
public class Vector
{
    private final double[] coords;
    ...
}
```



## 1.3 背包、队列和栈

- 背包、队列、栈：bag、queue、stack；
  - 背包：
    - 不支持从中删除元素的集合数据类型；
    - 元素无序；
  - 队列：全称为先进先出（FIFO）队列
  - 栈：全称为下压栈，基于后进先出（LIFO）策略；
    - 遍历顺序与元素入栈顺序相反；
- 泛型中的类型参数必须为引用类型；
- Java 中不允许创建泛型数组，但可使用类型转换间接实现该目的；
  - Java 编译器将给出一条警告，但可以忽略；

```java
a = (Item[]) new Object[cap];	
// 创建一个 Object 类型的数组，并将其转换为泛型类型；
```

- 如何跳出由键盘输入的`while(!in.hasNext())`的循环：
  - 由于`in`一直等待输入，因此返回结果始终为`true`，导致循环无法退出；

```java
while(!in.hasNext())
{
    if(condition)		// 设置退出循环的条件；
        break;
}
```



- 游离：保存一个不需要的对象的引用；
- 迭代：需要实现接口`Iterable`，且该类中应实现方法`Iterator<I> iterator()`；
- 使用`javac`命令编译文件时，将为内部类生成单独的`.class`文件；
  - E.g. `Stack$Node.class`，表示`Node`是`Stack`的内部类；
- 私有嵌套类的特点：只有包含它的类能直接访问嵌套类的实例变量，因此无需指出嵌套类实例变量的访问限制符；



## 1.4 算法分析

- 常见的增长数量级函数：

  - $logN$，对数级别，对数的底数与增长的数量级无关，因此在符号中不体现底数；
  
  - $N$，线性级别；
  - $NlogN$，线性对数级别；
  
- 不同增长数量级函数的运行时间差异：

  - $NlogN>N>>logN>1$；
  - 处理大规模的问题，应设计对数级别、线性级别、线性对数级别的算法；



## 1.5 Union-find (并查集算法)

- 动态连通性问题：
  - 触点：指对象；
  - 分量/连通分量：指等价类，即具有连接关系的对象组成的最大集合；
- 并查集算法仅能判断两个对象之间是否存在连接，但不能给出连接路径；
- 归并：几个合在一起或一个合到另一个里去；
- 动态连通性问题：
  - union-find 算法；
  - quick-union 算法；
  - 加权 quick-union 算法：$2^n$个触点最坏情况下的输入，使树的深度为 n；
    - 由于将小树连接到大树的限制，使得树的深度不为$2^n$；





# 2. 排序

## 2.1 初级排序算法

-  原地排序算法：指无需额外内存的算法；
-  排序算法适用于任何实现了`Comparable`接口的数据类型；
   - 在该类中需要实现一个`compareTo()`方法，定义对象的自然次序；
-  倒置：指数组中两个元素的实际位置与排序位置相反；
-  部分有序：数组中倒置的数量小于数组大小的某个倍数；
-  初级排序算法：
   - 选择排序：
     - 运行时间与输入无关；
       - 无法利用输入的初始状态信息；
       - 某次遍历数组不能为下次遍历数组提供信息；
     - 数据移动较少；
   - 插入排序：
     - 对于有序数组，其运行时间为线性的；
     - 对部分有序数组，插入排序的效率较高；
   - 希尔排序：shell sort;
     - 目前最好的递增序列：1, 5, 19, 41, 109, 209, ...
       - 表达式复杂；
       - 可使用$h=3h+1$替代，但效果稍差；
     - 对于中等规模的数组，运行时间尚可接受；
     - 希尔排序是基于插入排序的以下两点性质而提出的改进方法：
       - 插入排序在操作几乎已经排好序的数组时，效率可达到线性时间复杂度；
       - 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；



## 2.2 归并排序

- 归并排序：merge sort；
  - 优点：时间复杂度为$NlogN$；
    - 最坏情况下，基于比较的排序算法需要的比较次数为$NlogN$；
  - 缺点：
    - 空间复杂度为$N$；
- 改进方法：
  - 对小规模子数组使用插入排序，E.g. 长度小于15；
  - 检测到子数组有序时，跳过归并算法；
  - 不将元素复制到辅助数组；
    - 即在递归调用的每个层次，交换输入数组和辅助数组的角色；
- 自顶向下的归并排序、自底向上的归并排序：
  - 自底向上的归并排序相较于标准递归方法（自顶向下的归并排序），代码量更少；
- 归并排序与希尔排序的运行时间差距在常数级别之内；






# ==Schedule==

- 每日20页，9月23日前完成；



# N. 典型案例

## N.1 杨辉三角

- 对于不符合公式的部分结果，单独予以计算；
```java
// 定义二维不规则数组；
int rowNum = 7;
int[][] array = new int[rowNum][];
for(int i=0; i<rowNum; i++)
{
	array[i] = new int[i+1];
}

// 计算结果并填充数组；
// 当j=0时，k<=j不成立，因此不进入第三层循环，计算结果为1；
// 当j=array[i].length-1时，计算结果恰为1；
int defaultNum;
for(int i=0; i<rowNum; i++)
{
    for(int j=0; j<array[i].length; j++)
    {
        defaultNum = 1;
        for(int k=1; k<=j; k++)
        {
            defaultNum = defaultNum*(i-k+1)/k;
        }
        array[i][j] = defaultNum;
    }
}
```



## N.2 根据离散概率返回值

- Description：数组`array`中存放着一组离散概率值，`array[i]`表示数字`i`出现的概率，请根据数字的概率随机返回 i 值；
- Approach：
  - 将各个数字出现的概率对应到数轴上的一个区间；
  - 各个概率之和为1，对应于各个区间首尾相接，覆盖数轴上从0-1的区域；
  - 现随机生成一个[0,1)之间的数，该数落入某个区间的概率为该区间的长度，即`a[i]`所表示的概率值；



# References

[1] https://www.coursera.org/learn/algorithms-part1?.
[2] https://www.coursera.org/learn/algorithms-part2?.
[3] Sedgewick, R. & Wayne, K. (2016). *Algorithms Fourth Edition*. Boston: Addison-Wesley.