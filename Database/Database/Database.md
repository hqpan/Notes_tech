[toc]

# 版权声明

- 数据库系列学习笔记来源于 Abraham Silberschatz，Henry F.Korth 和 S.Sudarshan 所著 *Database System Concepts 6th edition* [1]；
- 该系列笔记不以盈利为目的，仅用于个人学习、课后复习及科学研究；
- 如有侵权，请与本人联系（hqpan@foxmail.com），经核实后即刻删除；
- 本文采用 [署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)](https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh) 协议发布；

# 1. 数据库基本概念

## 1.1 定义

- DBS：Database System，数据库系统；
  - 数据库：相互关联的数据集合；
  - 访问数据的应用程序；
- DBMS：database management system，E.g. MySQL;
- SQL:  Structured Query Language ，结构化查询语言；
  - 发音：为字母 S-Q-L 或 sequel ['sikwəl] ；
  - query，n. & vt. 查询；
- UML：Unified Modeling Language，统一建模语言，unify，vt. 统一；
- 数据文件：即存储数据库自身；
- 数据字典：存储关于数据库结构的元数据，尤其是数据库模式；
- 索引：便于快速访问数据项；
- 数据库系统性能的度量指标：
  - 吞吐量：给定时间内完成任务的数量；
  - 响应时间：完成单个任务所需时间；

## 1.2 数据视图

- 数据抽象：
  - 物理层；
  - 逻辑层：
    - 数据间的关系，与物理层之间存在物理数据独立性；
    - 物理数据独立性：应用程序不依赖于物理模式；
  - 视图层；
- 实例：某个时刻数据库中所有信息特定取值的集合；
- 模式：schema，数据库的总体设计，描述表的特性，E.g. 表中包含何种数据、数据如何分解、如何存储、各部分信息如何命名、各个表之间的关系；
  - 物理模式：在物理层描述数据库的设计；
  - 逻辑模式：在逻辑层描述数据库的设计，使用该模式构造应用程序；
  - 子模式：subschema，即数据库在视图层的模式；
- 数据模型：描述数据之间的关系；
  - 关系模型：表示数据间的关联；
  - 实体-关系模型：entity-relationship model，E-R；
  - 基于对象的数据模型：即面向对象的数据模型；
  - 半结构化数据模型：允许相同的数据项具有不同的属性集，E.g. XML 可用于表示半结构化数据；

## 1.3 数据库语言

- 数据库语言的不同部分;
  - DDL：数据定义语言，输出存放在包含元数据的数据字典中，数据字典仅能由 DBS 自身访问和修改；
  - DML：数据操纵语言；
- 一致性约束：
  - 域约束：每个属性均有对应的取值范围约束；
  - 参照完整性约束：某些属性集在不同关系中出现，其值必须相等；
  - 断言；
  - 授权：给每个用户不同的权限；

## 1.4 事务管理

- 事务正确执行的四个基本要素：简写为 ACID；
  - 原子性：Atomicity；
  - 一致性：Consistency；
  - 隔离性：Isolation，若两个事务运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统；
  - 持久性：Durability；

## 1.5 数据库体系结构

- 数据库体系结构:
  - 集中式数据库；
  - 客户机/服务器系统；
  - 并行数据库系统；
  - 分布式数据库系统；

# 2. 关系模型相关定义

- 数据库模式和数据库实例：
  - 数据库模式：数据库的逻辑设计；
  - 数据库实例：特定时刻下的快照；
- 关系：关系是集合，其中不含重复元组；
  - 关系实例：包含一组特定的行；
  - 关系模式：属性、属性类型、各属性的值域、关系上的约束；
  - 关系模型：用表的集合表示数据间的联系；
- 域：属性的值域；
- 属性：指代列；
- 导出列：即给列取别名；
- field：字段/计算字段，计算后得到的列，便于区分表中原有的列；
- 行：亦称记录；
- n 元组：有 n 个值的元组，对应于表中的一行；
- 超码：一个或多个属性的集合，可用于唯一标识一个元组；
  - 候选码：最小的超码；
  - 主码：即主键，被设计者选中，用于区分不同元组的候选码；
    - 主键值不能为空，不能修改、重用，若某行从表中删除，则它的主键不能赋给以后的新行；
    - 可取多个 column 组合作为主键；
- 外码：即外键，E.g. 关系$r_2$的主键是关系$r_1$中的属性；
  - $r_1$：外码依赖的参照关系；
  - $r_2$：外码的被参照关系；
- 参照完整性约束：参照关系中对应属性值相等；

# 3. 形式化关系查询语言

## 3.1 基本关系代数运算

- 相容：指两个关系具有完全相同的属性；
- 关系代数基本运算：
  - 选择：筛选出满足给定条件的元组；
  - 投影：筛选出部分列，以集合形式（去重）返回；
  - 并：要求参与计算的关系是相容的；
  - 差：要求参与计算的关系是相容的；
  - 笛卡尔积：将两个关系中的元组拼接得到$n\times m$个元组，对于重名的属性使用关系名加以区分；
  - 更名；

## 3.2 附加的关系代数运算

- 附加的关系代数运算：
  - 交；
  - 自然连接：
    - 在笛卡尔积的基础上，仅拼接所有相同属性上具有相等值的元组，运算结果中不含重复属性；
    - 若两个关系中不含有相同属性，则自然连接的结果与笛卡尔积的结果相同；
  - 外连接：保留没有关联行的行；
    - 左外连接：保留左表中没有关联行的行，将缺失的内容记为 NULL；
    - 右外连接；
    - 全外连接；

## 3.3 扩展的关系代数运算

- 集合：不允许出现重复值，值出现的顺序是任意的；
- 多重集：允许出现重复值，值出现的顺序是任意的；
- 扩展的关系代数运算：聚集（使用聚集函数）；

# 4. 数据库设计和E-R模型

## 4.1 定义

- 度：参与联系集的实体集数量；
- 属性：
  - 组合属性：可划分为若干简单属性，E.g. address 可划分为 street、city、state 等信息；
  - 多值属性：E.g. 属性 phone_number 可能有多个值；
  - 派生属性：无需存储，可由基属性计算得到，E.g. date_of_bath 和 age；
- 约束：
  - 映射基数：一个实体通过一个联系集能关联的实体数量，E.g. 一对一，一对多……；
  - 参与约束：
    - total：实体集中的**所有**实体均参与到某个联系集中；
    - partial：实体集中的**部分**实体均参与到某个联系集中；

## 4.2 E-R 图

- E-R 图的组成部分：
  - 实体；
  - 属性；
  - 联系；
- 映射基数：一个实体通过一个联系集能关联的实体个数；
  - 一对一；
  - 一对多；
  - 多对一；
  - 多对多；
- 强实体集和弱实体集：
  - 强实体集：有主码；
  - 弱实体集：无主码，与标识实体集/属主实体集关联后才有意义；
- 标识性联系：弱实体集与标识实体集之间的联系；

# 5. 关系数据库设计

## 5.1 关系设计的特点

- 关系数据库的设计目标：设计满足适当范式的模式，避免存储信息冗余；
- 函数依赖：设 A​、B 为关系 R 的两个属性集合，若 R 中任意两个元组的 A 属性值相同时，其 B 属性值也相同，则称 A 函数决定 B ，或 B 函数依赖于 A；
  - 平凡的函数依赖：在所有关系中都成立的函数依赖；
  - 部分依赖：设对于属性集合 A、B，存在$A\rightarrow B$，且$A'$是 A 的真子集，若存在$A'\rightarrow B$，则称 B 部分函数依赖于 A；
  - 完全依赖：设对于属性集合 A、B，存在$A\rightarrow B$，若对于 A 的任一真子集$A'$，均不存在$A'\rightarrow B$，则称 B 完全函数依赖于 A；
  - 传递函数依赖：设 A、B、C 是互不相同的属性集合，若存在$A\rightarrow B$，$B\rightarrow C$，则称 C 传递函数依赖于 A；
- 有损分解和无损分解：
  - 有损分解：将一个模式分解为多个模式后，产生信息丢失；
  - 无损分解；
- 表达数据库一致性约束的方式：
  - 主码约束；
  - 函数依赖；
  - check 约束；
  - 断言；
  - 触发器；
- 不符合范式的关系可能产生的异常;
  - 数据冗余；
  - 修改异常：仅修改一个记录中的信息，而另一个记录中的信息未被修改；
  - 删除异常：删除一个信息后，可能丢失其它信息；
  - 插入异常：例如，无法插入新成立的学院信息，直至其拥有第一位教师；

## 5.2 范式

- 原子域：E.g. `CS224`不是一个原子域，其中子字符串具有单独的含义；
- $F^+$：表示集合$F$的闭包，即能从$F$集合推导出的所有函数依赖的集合；
- ==面试题== 第一范式：1 NF;
  - 关系模式中所有属性的域均不可分；
  - 无组合属性和多值属性；
- ==面试题== 第二范式：2 NF，非主键属性完全依赖于主键属性；
  - 解决方案：通过关系分解消除部分依赖；
  - 不符合第二范式的关系可能出现数据冗余，或在增删改等过程中出现异常；
- ==面试题== 第三范式：3 NF，在满足第二范式的基础上，关系中不存在非主键属性**传递函数依赖于**主键属性；
  - 解决方案：通过关系分解消除传递依赖；
  - 不符合第三范式的关系也可能存在数据冗余和增删改等操作异常；
  - 第三范式允许某些 BCNF 中不允许的函数依赖；
- ==面试题== Boyce-Codd 范式：不存在“任意一个非平凡的函数依赖$A\rightarrow B$，其中 A 不是关系的超码”；
  - Boyce-Codd Normal Form，BCNF，可消除所有基于函数依赖能够发现的冗余；
  - 满足 BCNF 的关系不是保持依赖的，不利于执行检查函数依赖的计算；
  - 任何满足 BCNF 范式的模式必定满足第三范式；

# 6. 数据存取

- ==Unsolved==

# 7. 查询优化

- ==Unsolved==

# 8. 事务管理

## 8.1 事务的特性

```mermaid
graph LR
	1(原子性) --串行执行/并发--> 2(一致性)
	3(隔离性) --并发--> 2(一致性)
	2(一致性) --> 4(执行结果正确)
	5(持久性) --> 6(防止系统崩溃)
```

- ==面试题== 事务的特性：ACID；
  - Atomicity：原子性，事务不可分，其中的所有操作或者全部执行，或者均不执行；
    - 由恢复系统实现；
    - 借助回滚日志记录信息，若事务中止，则通过日志回滚；
  - Consistency：一致性，事务执行前后，数据库保持一致性状态；
    - 由编写事务的开发人员实现；
  - Isolation：隔离性，事务执行过程中，对其它事务不可见；
    - 由并发控制系统实现；
  - Durability：持久性，事务提交后，其对数据库的修改被永久保存；
    - 由恢复系统实现；
    - 借助重做日志，为已崩溃的系统恢复数据；

## 8.2 事务的状态

![事务状态图](./Pictures/TransactionStatus.png)

- 事务的状态：
  - 活动状态：初始状态，即事务执行时所处状态；
  - 部分提交状态：事务的最后一条语句执行完毕后，实际输出结果仍可能临时驻留在内存中；
  - 事务状态下的两种选择：
  - 中止状态；
  - 失败状态；
- 中止状态下的两种选择：
  - 重启事务：当硬件错误引发事务中止时适用；
  - 杀死事务：当事务内部的逻辑错误引发事务中止时适用；

## 8.3 并发一致性问题

- ==面试题== 并发一致性问题：
  - 丢失修改：E.g. 事务$T_i$、$T_j$先后修改同一数据项时，后者将覆盖前者；
  - 脏读：当前事务读取了其它未提交事务修改的数据；
  - 不可重复读：在当前事务两次读取同一数据项期间，数据项被另一事务修改；
  - 幻影读：
    - 本质上属于一种不可重复读；
    - 事务$T_i$读取某个范围内的数据时，$T_j$在该范围内插入新的数据，当$T_i$再次读取数据时，无法得到相同结果；
- 事务隔离性被破坏，将导致并发一致性问题，可通过并发控制保证隔离性；

## 8.4 可串行化

- 并发的优势：
  - 提高吞吐量和资源利用率；
  - 减少事务的平均响应时间；
- 并发控制系统的作用：实现可串行化调度，即并发调度的结果等价于串行调度；
- 冲突：对于事务 I 和 J，仅当其对同一数据项操作，且至少有一个 write 指令时，I 和 J 是冲突的；

|    事务 I    |    事务 J    | 是否冲突 |
| :----------: | :----------: | :------: |
| I = read(Q)  | J = read(Q)  |    F     |
| I = read(Q)  | J = write(Q) |    T     |
| I = write(Q) | J = read(Q)  |    T     |
| I = write(Q) | J = write(Q) |    T     |

- 冲突等价：若调度$S$通过一系列非冲突指令交换，转换为$S'$，则称调度$S$是冲突可串行化的；
- 冲突可串行化：若调度$S$与一个串行调度$S'$冲突等价，则称调度$S$是冲突可串行化的；

## 8.5 可恢复性

- 可恢复性：确保事务的原子性，即当事务$T_i$失败时，依赖于$T_i$的所有事务（即读取了$T_i$所写数据项的事务）也随之中止；
- 可恢复调度：对于事务$T_i$和$T_j$，若事务$T_j$读取了$T_i$所写的数据项，则应确保$T_i$先于$T_j$提交；
- 级联回滚：因某个事务故障引发一系列事务回滚；
- 无级联调度：
  - 若事务$T_j$读取了由$T_i$所写的数据项，则$T_i$必须在$T_j$这一读操作前提交；
  - 由定义可知，无级联调度也是可恢复调度；
- ==面试题== 事务隔离性级别：
  - 可串行化：
    - 不会出现并发一致性问题；
    - 实现方式：需要加锁，确保事务串行执行；
  - 可重复读：确保同一事务多次读取同一数据项，结果一致；
  - 已提交读：一个事务只能读取已提交的事务所做的修改，即未提交的事务所做的修改对其它事务不可见；
  - 未提交读：未提交的事务所做的修改对其它事务可见；
  - 注意：以上所有隔离性级别均不允许脏写，即当一个数据项被另一个尚未提交的事务写入时，不允许对该数据项执行写操作；
- 隔离级别处理并发一致性问题：

|          | 脏读 | 不可重复读 | 幻影读 |
| :------: | :--: | :--------: | :----: |
| 可串行化 |  T   |     T      |   T    |
| 可重复读 |  T   |     T      |   F    |
| 已提交读 |  T   |     F      |   F    |
| 未提交读 |  F   |     F      |   F    |



# Unsolved

- 通过 Commit 提交事务，通过 Rollback 回滚事务；

# TODO

- 总页数：330 页；
- 当前进度：Page 243，316；
- 每天 13 页，7 月 31 日完成；
- 处理所有面试题；
- 笔记整理：Chapter 1-2、4、7-8 已完成；

# References

[1] Abraham Silberschatz, Henry F.Korth, S.Sudarshan. 数据库系统概念[M]. 机械工业出版社, 2013. 