[toc]



# 版权声明

- 深度学习系列学习笔记来源于 Aston Zhang，Zack C. Lipton，李沐和 Alex J. Smola 所著 *Dive into Deep Learning* [1]；
- 该系列笔记不以盈利为目的，仅用于个人学习、课后复习及科学研究；
- 如有侵权，请与本人联系（hqpan@foxmail.com），经核实后即刻删除；
- 本文采用 [署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)](https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh) 协议发布；

# 1. 深度学习简介

## 1.1 定义

- 表征学习：是机器学习中的一类方法，用于自动找出适合表示数据的方式，而深度学习是具有多级表示的表征学习方法，可以逐级表示越来越抽象的概念或模式；
- $\mathcal{B}$：mini-batch SGD 中，每个小批量中的样本数量，即 batch size；
- $\eta$：学习率；

## 1.2 数据操作

- `torch.Tensor`：用于存储和变换数据，类似于多维数组，支持GPU加速；
  - tensor：n. 张量，可视为一个多维数组；
  - 标量：0维张量；
  - 向量：1维张量；
  - 矩阵：2维张量；
- 内存共享的数据操作：
  - 索引操作；
  - `view()`：若某个输入维度为-1，则自动计算该维度大小；
  - `torch.add(x, y, out = y)`；
  - `y += x`；
  - `y.add_(x)`：函数名中带下划线的函数，会修改Tensor本身，不带下划线的函数将返回一个新的Tensor；
- 非内存共享的操作：
  - `clone()`：还有⼀个好处是会被记录在计算图中，即梯度回传到副本时也会传到源 Tensor；
  - `y = x + y`；
- Tensor 和 numpy 相互转换：这两个函数所产⽣的的 Tensor 和NumPy 中的数组共享内存；
  - `numpy()`；
  - `from_numpy()`；
  - 注意：
    - `torch.tensor()`可将 NumPy 中的 array 转换为 Tensor，且不共享内存；
    - 所有在CPU上的 Tensor （除了 CharTensor ）都⽀持与NumPy数组相互转换；
- ⽅法 to() ：可将 Tensor 在CPU和GPU（需要硬件⽀持）之间相互移动；
- `.cuda()`方法：将Tensor转换为GPU的Tensor，以便使用GPU加速；
- 3 种加法：
  - x + y；
  - t.add(x, y)；
  - t.add(x, y, out = result)；
- 函数名以`_`结尾的函数：均为 inplace 方式，即会修改原始数据；

## 1.3 自动求梯度

- 链式法则：即反向传播，用于更新网络参数；
- grad 在反向传播过程中是累加的，每次反向传播过程中都会累加此前的梯度，因此反向传播之前需将梯度清零；
- Variable：
  - 简单封装了Tensor，支持几乎所有的Tensor操作，`.backward()`方法可实现反向传播；
  - 与Tensor接口几乎一致，可等同使用；

# 2. 深度学习基础

## 2.1 自动求梯度

- 在 y.backward() 时，如果 y 是标量，则不需要为 backward() 传⼊任何参数；否则，需要传⼊⼀个与 y 同形的 Tensor；
- grad在反向传播过程中是累加的(accumulated)，即每⼀次运⾏反向传播，梯度都会累加之前的梯度，所以⼀般在反向传播之前需把梯度清零；
- 如果想要修改 tensor 的数值，但是⼜不希望被 autograd 记录（即不会影响反向传播），那么可对 tensor.data 进⾏操作；
- 反向传播前梯度为None；

## 2.2 线性回归

- 线性回归：
  - 假设输出与各个输⼊之间是线性关系；
  - 既可以⽤神经⽹络图表示线性回归，⼜可以⽤⽮量计算表示该模型；
  - 尽可能采⽤⽮量计算，以提升计算效率；
  - 作为⼀个单层神经⽹络，线性回归输出层中的神经元和输⼊层中各个输⼊完全连接。因此，线性回归的输出层⼜叫全连接层；
- 损失函数：计算预测值与真实值之间差值的函数，是以模型参数为参数的函数；
- 超参数：
  - 人为设定的 参数，而非通过模型训练学到的参数；
  - 调参：一般指反复试错调节超参数；
- 解析解和数值解：
  - 解析解：若模型和损失函数形式较为简单时，其误差最⼩化问题的解可⽤公式表示；
  - 数值解：大多数深度学习模型没有解析解，只能通过优化算法有限次迭代模型参数尽可能降低损失函数的值；
- ⼩批量随机梯度下降（mini-batch stochastic gradient descent）：mini-batch SGD；
  - 用途：一种求数值解的优化算法；
  - 实现方式：先选取⼀组模型参数的初始值，如随机选取；接下来对参数进⾏多次迭代，使每次迭代都可能降低损失函数的值。在每次迭代中，先随机均匀采样⼀个由固定数⽬训练数据样本所组成的⼩批量（mini-batch） ，然后求⼩批量中数据样本的平均损失有关模型参数的导数（梯度），最后⽤此结果与预先设定的⼀个正数的乘积作为模型参数在本次迭代的减⼩量；
- 特征数：亦称特征数、特征向量维度，即神经网络中第一层输入值的个数；
- 输出层不涉及计算，因此计算神经网络层数时不统计输出层；
  - 线性回归可视为一个单层神经网络；
- 全连接层/稠密层：全连接层的每一个结点都与上一层的所有结点相连，将前边提取到的特征综合起来；
- 在一个周期（epoch）中，使用训练数据集中的所有样本各一次；

## 2.3 Softmax 回归

- Softmax 回归：
  - ⼀个单层神经⽹络，也是一个全连接层；
  - 将输出值变成值为正且和为1的概率分布；
  - 损失函数：交叉熵，适合衡量两个概率分布的差异；

## 2.4 多层感知机

- MLP：Multilayer Perceptron，多层感知机；
  - 在单层神经⽹络的基础上引⼊了⼀到多个隐藏层；
  - 多层感知机中的隐藏层和输出层都是全连接层；
  - 每个隐藏层的输出通过激活函数进⾏处理；
- 隐藏层的输出：亦称为隐藏层变量或隐藏变量；
- 为什么需要多层感知机中需要使用激活函数？
  - 全连接层只是对数据做仿射变换，⽽多个仿射变换的叠加仍然是⼀个仿射变换；
- 常见的激活函数：
  - ReLU 函数；
  - Sigmoid 函数：
    - 值域在0到1之间；
    - 当输⼊接近0时，sigmoid函数接近线性变换；
  - tanh 函数：
    - 值域在到-1和1之间；
    - 当输⼊接近0时，tanh函数接近线性变换；

## 2.5 模型选择、欠拟合与过拟合

- 一味地降低训练误差并不意味着泛化误差一定会降低，机器学习模型应关注降低泛化误差；
- 交叉验证集：用于选择模型；
- K 折交叉验证：
  - 将训练集切分为 K 个不重合的子数据集；
  - 做 K 次模型训练和验证；
  - 其中每次使用 K-1 个子数据集训练模型，使用 1 个子数据集验证模型；
  - 对 K 次训练误差和测试误差求均值，即为最终的训练误差和测试误差；
  - 意义：当训练数据不够时，预留大量的验证数据太过奢侈，故使用 K 折交叉验证；
- 泛化误差不会因为数据集的增大而增大；
- 权重衰减：
  - $\frac{\lambda}{2n}||w||^2$：其中$||w||^2$表示所有权重参数的平方和；
  - 等价于$L_2$范数正则化，常使得学到的权重参数接近于 0；
  - Pytorch 默认对权重参数和偏差参数同时衰减，可为权重参数和偏差参数分别构造优化器实例，从而单独设置仅对权重参数进行衰减；
  - 意义：为模型损失函数增加惩罚项，使得学到的模型参数值较小，避免过拟合；

# 3. 深度学习计算

## 3.1 模型构造

- 模型构造：
  - 可通过继承 Module 类来构造模型；
  - Sequential 、 ModuleList 、 ModuleDict 类都继承⾃ Module 类；
  - 虽然 Sequential 等类可以使模型构造更加简单，但直接继承 Module 类可以极⼤地拓展模型构
    造的灵活性；
- Module 类：
  - 是一个模型构造类，是所有神经⽹络模块的基类，可以继承它来定义我们想要的模型；
  - 可以实例化该类（继承 Module 类的子类）得到模型变量`net`；
  - 重载`__init__`函数：声明带有模型参数的层；
  - 重载`forward`函数：定义前向计算，即正向传播；
  - ⽆须定义反向传播函数，系统可通过`backward()`函数求解；
- Sequential 类：
  - 当模型的前向计算为简单串联各个层的计算时， Sequential 类可通过更加简单的⽅式定义模型；
  - 它可以接收⼀个⼦模块的有序字典（OrderedDict）或者⼀系列⼦模块作为参数来逐⼀添加 Module 实例，⽽模型的前向计算就是将这些实例按添加的顺序逐⼀计算；
  - 对于使⽤ Sequential 类构造的神经⽹络，可以通过⽅括号 [] 索引来访问⽹络的任⼀层，索引0表示隐藏层为 Sequential 实例最先添加的层；
- ModuleList 类：接收⼀个⼦模块的列表作为输⼊，然后也可以类似List那样进⾏append和extend操作；
- ModuleDict 类：接收⼀个⼦模块的字典作为输⼊, 然后也可以类似字典那样进⾏添加访问操作；

## 3.2 模型参数的访问、初始化和共享

- 访问模型参数：
  - 可以通过 Module 类的 parameters() 或者 named_parameters ⽅法来访问所有参数（以迭代器的形式返回），后者除了返回参数 Tensor 外还会返回其名字；
  - param 的类型为 torch.nn.parameter.Parameter ，这是 Tensor 的⼦类；
  - param 会⾃动被添加到模型的参数列表⾥，而 Tensor 不会⾃动被添加到模型的参数列表⾥；
- 参数初始化：
  - 如果只想对某个特定参数进⾏初始化，可以调⽤ Parameter 类的 initialize 函数，它与 Block
    类提供的 initialize 函数的使⽤⽅法⼀致；
  - init.norml_()：对参数进行正态分布初始化；
  - init.constant_()：使⽤常数来初始化权重参数；

# ==待整理的内容==

- 损失函数：
  - 线性回归：平方损失函数；
  - Softmax 回归：交叉熵损失函数；

# TODO

- ==旧版本进度==：
  - 总页数 220 = 198 + 20：Chapter 1-6，9；
- 学习计划：
  - 总页数：364 页；
  - 学习周期：每天10页，12月24日-01月27日；
  - 当前进度：Page 96， 3.12 已完成；
  - 今日进度：01 月 01 日，学完 Chapter 4.5，Page 134；
  - 需要追赶的进度：15 页；

# References

[1] Aston Zhang, Zack C. Lipton, Mu Li, Alex J. Smola. Dive into Deep Learning[M]. 人民邮电出版社, 2019. 