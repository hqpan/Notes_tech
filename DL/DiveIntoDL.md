[toc]



# 版权声明

- 深度学习系列学习笔记来源于 Aston Zhang，Zack C. Lipton，李沐和 Alex J. Smola 所著 *Dive into Deep Learning* [1]；
- 该系列笔记不以盈利为目的，仅用于个人学习、课后复习及科学研究；
- 如有侵权，请与本人联系（hqpan@foxmail.com），经核实后即刻删除；
- 本文采用 [署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)](https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh) 协议发布；

# 1. 深度学习简介

## 1.1 定义

- 表征学习：是机器学习中的一类方法，用于自动找出适合表示数据的方式，而深度学习是具有多级表示的表征学习方法，可以逐级表示越来越抽象的概念或模式；
- $\mathcal{B}$：mini-batch SGD 中，每个小批量中的样本数量，即 batch size；
- $\eta$：学习率；

## 1.2 数据操作

- `torch.Tensor`：用于存储和变换数据，类似于多维数组，支持GPU加速；
  - tensor：n. 张量，可视为一个多维数组；
  - 标量：0维张量；
  - 向量：1维张量；
  - 矩阵：2维张量；
- 内存共享的数据操作：
  - 索引操作；
  - `view()`：若某个输入维度为-1，则自动计算该维度大小；
  - `torch.add(x, y, out = y)`；
  - `y += x`；
  - `y.add_(x)`：函数名中带下划线的函数，会修改Tensor本身，不带下划线的函数将返回一个新的Tensor；
- 非内存共享的操作：
  - `clone()`：还有⼀个好处是会被记录在计算图中，即梯度回传到副本时也会传到源 Tensor；
  - `y = x + y`；
- Tensor 和 numpy 相互转换：这两个函数所产⽣的的 Tensor 和NumPy 中的数组共享内存；
  - `numpy()`；
  - `from_numpy()`；
  - 注意：
    - `torch.tensor()`可将 NumPy 中的 array 转换为 Tensor，且不共享内存；
    - 所有在CPU上的 Tensor （除了 CharTensor ）都⽀持与NumPy数组相互转换；
- ⽅法 to() ：可将 Tensor 在CPU和GPU（需要硬件⽀持）之间相互移动；
- `.cuda()`方法：将Tensor转换为GPU的Tensor，以便使用GPU加速；
- 3 种加法：
  - x + y；
  - t.add(x, y)；
  - t.add(x, y, out = result)；
- 函数名以`_`结尾的函数：均为 inplace 方式，即会修改原始数据；

## 1.3 自动求梯度

- 链式法则：即反向传播，用于更新网络参数；
- grad 在反向传播过程中是累加的，每次反向传播过程中都会累加此前的梯度，因此反向传播之前需将梯度清零；
- Variable：
  - 简单封装了Tensor，支持几乎所有的Tensor操作，`.backward()`方法可实现反向传播；
  - 与Tensor接口几乎一致，可等同使用；

# 2. 深度学习基础

## 2.1 自动求梯度

- 在 y.backward() 时，如果 y 是标量，则不需要为 backward() 传⼊任何参数；否则，需要传⼊⼀个与 y 同形的 Tensor；
- grad在反向传播过程中是累加的(accumulated)，即每⼀次运⾏反向传播，梯度都会累加之前的梯度，所以⼀般在反向传播之前需把梯度清零；
- 如果想要修改 tensor 的数值，但是⼜不希望被 autograd 记录（即不会影响反向传播，不影响梯度），那么可对 tensor.data 进⾏操作；

## 2.2 线性回归

- 线性回归：
  - 假设输出与各个输⼊之间是线性关系；
  - 既可以⽤神经⽹络图表示线性回归，⼜可以⽤⽮量计算表示该模型；
  - 尽可能采⽤⽮量计算，以提升计算效率；
  - 作为⼀个单层神经⽹络，线性回归输出层中的神经元和输⼊层中各个输⼊完全连接。因此，线性回归的输出层⼜叫全连接层；
- 损失函数：计算预测值与真实值之间差值的函数，是以模型参数为参数的函数；
- 超参数：
  - 人为设定的 参数，而非通过模型训练学到的参数；
  - 调参：一般指反复试错调节超参数；
- 解析解和数值解：
  - 解析解：若模型和损失函数形式较为简单时，其误差最⼩化问题的解可⽤公式表示；
  - 数值解：大多数深度学习模型没有解析解，只能通过优化算法有限次迭代模型参数尽可能降低损失函数的值；
- ⼩批量随机梯度下降（mini-batch stochastic gradient descent）：mini-batch SGD；
  - 用途：一种求数值解的优化算法；
  - 实现方式：先选取⼀组模型参数的初始值，如随机选取；接下来对参数进⾏多次迭代，使每次迭代都可能降低损失函数的值。在每次迭代中，先随机均匀采样⼀个由固定数⽬训练数据样本所组成的⼩批量（mini-batch） ，然后求⼩批量中数据样本的平均损失有关模型参数的导数（梯度），最后⽤此结果与预先设定的⼀个正数的乘积作为模型参数在本次迭代的减⼩量；
- 特征数：亦称特征数、特征向量维度，即神经网络中第一层输入值的个数；
- 输出层不涉及计算，因此计算神经网络层数时不统计输出层；
  - 线性回归可视为一个单层神经网络；
- 全连接层/稠密层：全连接层的每一个结点都与上一层的所有结点相连，将前边提取到的特征综合起来；
- 在一个周期（epoch）中，使用训练数据集中的所有样本各一次；

## 2.3 Softmax 回归

- Softmax 回归：
  - ⼀个单层神经⽹络，也是一个全连接层；
  - 将输出值变成值为正且和为1的概率分布；
  - 损失函数：交叉熵，适合衡量两个概率分布的差异；

## 2.4 多层感知机

- MLP：Multilayer Perceptron，多层感知机；
  - 在单层神经⽹络的基础上引⼊了⼀到多个隐藏层；
  - 多层感知机中的隐藏层和输出层都是全连接层；
  - 每个隐藏层的输出通过激活函数进⾏处理；
- 隐藏层的输出：亦称为隐藏层变量或隐藏变量；
- 为什么需要多层感知机中需要使用激活函数？
  - 全连接层只是对数据做仿射变换，⽽多个仿射变换的叠加仍然是⼀个仿射变换；
- 常见的激活函数：
  - ReLU 函数；
  - Sigmoid 函数：
    - 值域在0到1之间；
    - 当输⼊接近0时，sigmoid函数接近线性变换；
  - tanh 函数：
    - 值域在到-1和1之间；
    - 当输⼊接近0时，tanh函数接近线性变换；

## 2.5 模型选择、欠拟合与过拟合

- 一味地降低训练误差并不意味着泛化误差一定会降低，机器学习模型应关注降低泛化误差；
- 交叉验证集：用于选择模型；
- K 折交叉验证：
  - 将训练集切分为 K 个不重合的子数据集；
  - 做 K 次模型训练和验证；
  - 其中每次使用 K-1 个子数据集训练模型，使用 1 个子数据集验证模型；
  - 对 K 次训练误差和测试误差求均值，即为最终的训练误差和测试误差；
  - 意义：当训练数据不够时，预留大量的验证数据太过奢侈，故使用 K 折交叉验证；
- 泛化误差不会因为数据集的增大而增大；
- 权重衰减：
  - $\frac{\lambda}{2n}||w||^2$：其中$||w||^2$表示所有权重参数的平方和；
  - 等价于$L_2$范数正则化，常使得学到的权重参数接近于 0；
  - Pytorch 默认对权重参数和偏差参数同时衰减，可为权重参数和偏差参数分别构造优化器实例，从而单独设置仅对权重参数进行衰减；
  - 意义：为模型损失函数增加惩罚项，使得学到的模型参数值较小，避免过拟合；
- 丢弃法：Dropout；
  - 计算表达式中已对$h_i$除以$1-p$，因此丢弃法不改变输入的期望值；
  - 仅在模型训练过程中使用 Dropout，为得到确定的结果，在测试模型时不使用 Dropout；
  - 通常将靠近输入层的丢弃概率设置得较小；
  - 意义：设置丢弃概率，使隐层中的部分神经元值为 0，由于隐层神经元的丢弃是随机的，避免输出层的计算过度依赖某一个神经元，从而起到正则化的效果，避免过拟合；
- 代价函数：即目标函数，是“预测值与真实值之间的误差”与正则化项之和；
- 模型训练：
  - 反向传播过程会利用正向传播过程计算得到的中间变量，因此正向传播过程中计算得到的中间变量不能立即释放，故模型训练过程会比测试过程占用更多的内存；
  - Batch 越大，正向传播计算过程的中间变量越多，因此对较深的神经网络使用较大 Batch 运算时容易超内存；
  - 模型训练过程中，交替进行正向传播和反向传播；

## 2.6 数值稳定性和模型初始化

- 数值稳定性：网络层数过多使得模型数值稳定性变差；
  - 衰减：E.g. 若每层网络的参数值均小于1，则多层累乘后值接近于 0；
  - 爆炸：E.g. 若每层网络的参数值均大于1，则多层累乘后值接近于无穷；
- 模型初始化：
  - 模型参数应随机初始化，否则训练过程中，各个神经元的值将始终保持一致，等价于一个神经元；
  - PyTorch 中的 nn.module 模块参数均已完成了初始化，无需开发者自行考虑；
  - Xavier 随机初始化：
    - 一种随机初始化方法；
    - 意义：使得模型参数初始化之后，每层输出的方差不受该层输入的影响，每层梯度的方差也不受该层输出个数的影响；
# 3. 深度学习计算
## 3.1 模型构造

- Module 类：是 nn 模块提供的一个模型构造类，是所有神经网络模块的基类，可继承该类构造模型；
  - `__init__`函数：重载该函数，创建模型参数；
  - `forward`函数：重载该函数，定义正向传播计算过程；
  - 无需定义反向传播过程，调用`backward()`函数即可；
- Module 类的子类：
  - Sequential 类；
  - ModuleList 类；
  - ModuleDict 类；
- Sequential 类：
  - 可接收一个子模块的有序字典（OrderedDict），或一系列子模块作为参数，逐一添加 Module 实例；
  - 意义：若模型的前向计算为各层的简单串联，该类可简洁的定义模型；
- ModuleList 类：接收一个子模块的列表作为输入，也可类似于 List 那样进行 append 和 extend 操作；
- ModuleDict 类：接收一个子模块的字典作为输入，也可类似字典那样进行添加访问操作；

## 3.2 模型参数的访问、初始化和共享

- nn 的`init`模块：包含多种参数初始化方法；
- 访问模型参数：
  - Module 类的 parameters() 方法：以迭代器形式返回所有参数；
  - Module 类的 named_parameters() 方法：以迭代器形式返回所有参数名和参数；
    - 返回的参数名自动加上其所属的网络层数索引，以示区分；
    - 若网络仅有一层，则无索引前缀；
    - 对 net 使用方括号下标索引，可访问网络的任一层参数，索引从 0 开始；
    - 返回的 param 的类型为 torch.nn.parameter.Parameter，是 Tensor 的子类；
    - 如果一个 Tensor 是 Parameter，其将被自动添加到模型的参数列表里，而 Tensor 则不会；
- 参数初始化：
  - init.normal_()：以正态分布形式初始化参数；
  - init.constant_()：以常数初始化参数；
  - Parameter 类的 initialize 函数：
    - 与 Block 类的 initialize 函数使用方法相同；
    - 可对**某个**特定参数初始化；
- 共享模型参数的方法：
  - Module 类的 forward 函数中，若多次调用同一层，即可实现模型参数共享；
  - 若传入 Sequential 的模块是同一个 Module 实例，则其参数也是共享的；

## 3.3 自定义层

- 自定义不含模型参数的层：继承 Module 类，重载`__init__`函数和`forward`函数；
- 自定义含模型参数的层：
  - 应将参数定义为 Parameter、ParameterList 和 ParameterDict；
  - 因为如果一个 Tensor 是 Parameter，其将被自动添加到模型的参数列表里，而 Tensor 则不会；
  - 对 ParameterList 可进行 append 和 extend 操作，实现新增参数；

## 3.4 读取和存储

- 读写 Tensor：
  - save 函数：将单个 Tensor、多个 Tensor 组成的列表、从字符串映射到 Tensor 的字典保存到`.pt`文件中；
  - load 函数：将`.pt`文件中的数据读回内存；
- 读写模型：
  - state_dict：是一个从参数名映射到参数 Tensor 的字典对象；
  - 具有可学习参数的层、优化器均有 state_dict，其中包含参数的 Tensor 和优化器的状态以及优化器使用的超参数信息；
  - 保存和加载模型的方法：
    - 仅保存和加载模型参数 state_dict（推荐）；
      - save 函数；
      - load_state_dict 函数；
    - 保存和加载整个模型；

## 3.5 GPU 计算

- 默认情况下，PyTorch 在内存中创建数据，使用 CPU 计算；
  - 可在创建 Tensor 的时候指定 CPU 或 GPU；
  - GPU 上 Tensor 的计算结果仍位于 GPU 上；
  - 位于 CPU 上的数据不能直接和 GPU 上的数据进行运算，位于不同 GPU 上的数据也不能直接进行运算；
  - 即参与计算的所有数据应位于 CPU 上或同一块显卡上；
- 使用`.cuda()`可将 CPU 上的 Tensor 转换到 GPU 上；
  - 如果有多块 GPU，可用 .cuda(i) 表示第 i 块 GPU，索引从 0 开始；
  - .cuda() 和 .cuda(0) 等价；
- 使用`.cuda()`可将模型及其所有参数转换到 GPU 上；

# ==待整理的内容==

- 损失函数：
  - 线性回归：平方损失函数；
  - Softmax 回归：交叉熵损失函数；
- PyTorch：
  - linear()：用于设置全连接层；

# TODO

- ==旧版本进度==：
  - 总页数 220 = 198 + 20：Chapter 1-6，9；
- 学习计划：
  - 总页数：364 页；
  - 学习周期：每天15页，12月24日-01月17日；
  - 当前进度：Page 138， 4.6 已完成；
  - 今日进度：01 月 03 日，学完 Chapter 5.4，Page 155；

# References

[1] Aston Zhang, Zack C. Lipton, Mu Li, Alex J. Smola. Dive into Deep Learning[M]. 人民邮电出版社, 2019. 

