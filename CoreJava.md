[TOC]



# 0. 版权声明

- Java 系列读书笔记来源于 Cay S. Horstmann 所著《Java 核心技术 卷I 基础知识（第10版）》[1]；
- 该系列笔记不以盈利为目的，仅用于个人学习、课后复习及科学研究；
- 如有侵权，请与本人联系（hqpan@foxmail.com），经核实后即刻删除；



# 1. Java的基本程序设计结构

- `console`：n. 控制台，仪表板；

- `src`：源码目录；

## 3.1 简单的Java应用程序

- 在命令行窗口运行程序：
  - `javac filename.java`：编译器将源码转换成字节码；
  - `java filename`：Java虚拟机执行存放在`filename.class`中的字节码；
    - 虚拟机将从指定类中的`main`方法（或称为函数） 开始执行；
    - 在类的源文件中必须包含一个`main`方法；
      - `main`方法必须为`public`类型；
    - 将自定义的方法添加到类中，并在`main`方法中调用其他方法；
- Java 区分大小写；
- `public`：访问修饰符（access modifier），用于控制程序的其他部分对这段代码的访问级别；
- 类名以大写字母开头，若由多个单词构成，则采用驼峰命名法；
- 源码文件命名：源代码的文件必须与 `public` 类的名字相同，扩展名为 `.java`；
- 字节码文件：编译器将源码文件的名字，作为字节码文件名字，使用 `.class`作为扩展名，与原文件存储在同一个目录下；
- 方法的代码用大括号括起来，用大括号划分程序的各个部分（称之为“块”）；
  - 空白符会被编译器忽略，因此使用不同风格的大括号均可；

- `object.method(parameter)`：E.g. System.out.println("Hello, world!")，使用`System.out`对象调用`println`方法；
  - 每次调用`println`都会在新的一行上显示输出，然后终止该输出行；
  - `.print`方法输出时不换行；
  - 仅有`()`表明不带参数；



## 3.2 注释

- Java支持三种注释形式：
  - 其中第三种，以`/**`开始，以`*/`结束，该种注释可自动生成文档；
  - 在Java中不允许`/* ... */`注释嵌套；



## 3.3 数据类型

- Java：一种强类型语言，为每一个变量声明一种类型；
- 整型：byte，short，int， long；
- 浮点类型：float，double；

### 3.3.1 整型

- 表示数值：
  - 长整型`long`：后缀`L`或`1`；
  - 十六进制：前缀`0x`或`0X`；
  - 八进制：前缀`0`；
    - 八进制表示法容易与数值混淆，尽量少用，E.g. 010；
  - 二进制：前缀`0b`或`0B`；
  - （可选）为数字添加下划线：E.g. `1_000_000`；
    - 增加可读性；
    - 编译器运行时，将去除这些下划线；



### 3.3.2 浮点类型

- 浮点数值存在舍入误差；
  - 计算机使用二进制存储数值存在舍入误差；
  - Solution：使用`BigDecimal`类（不是一种数据类型），可表示任意精度；

- 表示数值：
  - float：后缀`F`或`f`；
    - 无后缀的浮点数默认为double类型；
  - （可选）double：后缀`D`或`d`；
- 三个特殊的浮点数：
  - 正无穷：
    - Float.POSITIVE_INFINITY；
    - Double.POSITIVE_INFINITY；
  - 负无穷：
    - Float.NEGATIVE_INFINITY；
    - Double.NEGATIVE_INFINITY；
  - NaN：不是一个数，各个NaN被认为不相同；
    - Float.NaN；
    - Double.NaN；
  - 检测某个值是否等于`Double.NaN`：
    - `if(Double.isNaN(x))`;
      - 正确；
    - `if(x==Double.NaN)`；
      - 错误；



### 3.3.3 char 类型

- 转义序列`\u`可出现在加引号的字符串之外；
  - 其他转义序列仅能出现在加引号的字符串之中；
- Unicode转义序列在解析代码之前得到处理；
  - 因此出现在注释中的转义序列，由于在解析代码之前被替换为字符，可能引发语法错误；



### 3.3.4 Unicode 和 char 类型

- code point（码点）与code unit（代码单元）：

  - 码点：编码表中某个字符对应的代码值；

  - 代码单元：每个字符用16位表示；
    - 常用 Unicode 字符使用一个代码单元表示；
    - 辅助字符使用两个代码单元表示；

- 在 Java 中，char 类型描述 UTF16 编码中的一个代码单元；

- 不建议使用 char 类型；

  - 除非需要处理 UTF16 代码单元；
  - 最好将字符串作为抽象数据类型处理；

- 返回代码单元数量：

```java
str1.length();			// 返回代码单元数量；
str2.codePointCount();	// 返回码点数量；
str3.charAt(n);			// 返回第 n 个代码单元；

// 获取第 i 个码点；
int index = str4.offsetByCodePoints(0, i);
int cp = str4.codePointAt(index);
```

  



### 3.3.5 boolean 类型

- boolean：adj.布尔数学体系的；
- 整型值与 boolean 值之间不能相互转换；



## 3.4 变量

- 不提倡在一行中申明多个变量；

  - E.g. `int i,j`；

  - 逐一声明变量可提高程序可读性；

- 申明一个变量后，必须用赋值语句对变量进行显式初始化；

  - 不能使用未初始化的变量；
  - 变量申明与初始化可置于同一行中；

  - Java中的申明可置于代码中的任意位置；
    - 提倡将申明放在靠近变量第一次使用的地方；

- 常量;

  - `final`：定义常量；

    - 常量只能被赋值一次，此后不能修改；
    - 习惯上，常量名中的每个字母均使用大写；

  - `static final`：定义类常量；

    - 类常量定义于`main`方法的外部；

    - 可在一个类的多个方法中使用；
    - 若一个常量被声明为`public`，则其他类中的方法也可使用该常量；



## 3.5 运算符

- 若被除数和除数均为整数，则表示整数除法；
  - 否则表示浮点除法；
  - 整数除以0，产生异常；
  - 浮点数除以0，结果为无穷大或NaN；

### 3.5.1 数学函数与常量

- `Math`类中，包含有各种数学函数；
  - `Math.sqrt(x)`：开方；
  - `Math.pow(x, a)`：x 的 a 次幂，两个参数均为 double 类型；
  - `Math.PI`：近似表示 π 的常量；
  - `Math.E`：近似表示 e 的常量；
- `floorMod(position+adjustment, 12)`，若除数为负数，取余/求模时余数亦为负数；
- 在源文件顶部加上`import static java.lang.Math.*;`，则不必在数学方法名和常量名前添加前缀`Math`；
- 运行速度与可移植性之间的权衡：
  - `Math`类中所有方法的例程：运行速度快；
  - `StaticMath`类：在各个平台上得到相同的结果；
  - 可移植性：确保同一个浮点数计算，在不同的虚拟机上运行得到相同的结果；



### 3.5.2 数值之间的转换

- 数值之间的转换：
  - 合法转换：不丢失信息的转换；
  - 强制类型转换：丢失信息的转换；
    - 截断小数部分；

- `Math.round()`方法：

  - 返回离该值最近的一个整数；
  - 该方法返回的数据类型为 long；

- 自增自减运算符会改变变量的值，因此它们的操作数不能是数值；

  - 前置的`++`或`--`会先完成加1；
  - 后置的`++`或`--`会使用变量原来的值；
  - 建议不在表达式中使用自增自减运算符，以免让人困惑；

- 三元操作符：

  ```java
  x<y?x:y
  ```

- 掩码（mask）：指一串二进制数字，通过与目标数字的按位操作，实现屏蔽指定位的功能；

- 位运算符：

  - `&`、`|`不使用短路求值；
  - `^`：位运算符，异或 xor；
  - `>>`：按位右移，高位用符号位填充；
  - `>>>`：按位右移，高位用0填充；
  - `<<`：按位左移，低位用0填充；
    - 不存在`<<<`；

- 使用位运算符的注意事项：

  - `float`、`double`不能执行移位操作；
  - `byte`、`short`移位前被自动转换为`int`类型，然后执行移位操作；
  - 若左操作数为`int`类型，则先将左操作数对32取模，然后执行移位操作；
    - E.g. `1<<35`等价于`1<<3`；
  - 若左操作数为`long`类型，则先将左操作数对64取模，然后执行移位操作；



## 3.6 字符串

### 3.6.1 术语

- `String`类对象：该类未提供用于修改字符串的方法，因此被称为不可变字符串；



### 3.6.2 子串

- `String`类的`substring(a,b)`方法：
  - 从字符串中提取第 a 至 b-1 个字符，组成新的字符串；
  - 提取出的子串长度为 b-a；



### 3.6.3 拼接

- 字符串拼接：使用`+`；

  - 当一个非字符串值与一个字符串进行拼接时，前者被转换为字符串；
  - 任何一个 Java 对象均可转换为字符串；

- 静态`join`方法：将多个字符串拼接后，使用界定符分隔；

  ```java
  String all = String.join("/", "S", "M", "L", "XL");
  ```



### 3.6.4 检测字符串是否相等

- 检测字符串的内容是否相同：

  ```java
  str1.equals(str2);				// 检查字符串内容是否相等；
  str1.equalsIgnoreCase(str2);	// 不区分大小写；
  ```

- `str1 == str2`：用于判断字符串在内存中的地址是否相同；

  ```java
  String str1 = "hello";
  String str2 = "hello";
  // java 在缓冲区查找是否存在常量对象“hello”；
  // 若存在该对象，则将该对象地址赋值给 str2；
  
  new String str1 = "hello";
  new String str2 = "hello";
  // 直接在内存中开辟一个存储空间，并将该对象地址赋值给 str2；
  ```




### 3.6.5 空串与 NULL 串

- 空串：长度为0，```""```；

  - 判断字符串是否为空串：

  ```java
  if(str.length()==0)						// 判断空串；
  if(str.euqals(""))						// 判断空串；	
  ```

- NULL 值上不能调用方法，会报错：

  - 因此先判断是否为 NULL 串，后判断是否为空串；

  ```java
  // 判断该字符串不是 NULL 串，也不是空串；
  if(str != null && str.length() != 0)
  ```

  

 ### 3.6.6 构建字符串

- 频繁使用字符串连接（`+`）效率低下，使用`StringBuilder`类避免该问题；

```Java
StringBuilder builder = new StringBuilder();
builder.append("ch");
builder.append("str");
String completedString = builder.toString();  
// 返回一个与构建器或缓冲器内容相同的字符串；
```

  

## 3.7 输入输出

## 3.7.1 读取输入

- 若使用的类不在`java.lang`包中，则应使用`import`加载该包；

  - `Scanner`类定义在`java.util`中；

- 构造一个`Scanner`对象，并与标准输入流`System.in`关联；

```java  
Scanner in = new Scanner(System.in);
String name = in.nextLine();		
// nextLine 方法读取一行；
// next 方法读取一个单词；

int age = in.nextInt();				
// nextInt 方法读取一个整数；
// nextDouble 方法读取一个浮点数；
```






# References

[1] Cay S. Horstmann. Java 核心技术 卷I 基础知识（第10版）[M]. 周立新,陈波,叶乃文 等译. 北京: 机械工业出版社, 2016. ︎